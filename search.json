[{"title":"C++疏漏记录","path":"/2024/12/27/cpp/","content":"作为靠C++吃饭的选手，但是好多地方都理解的不够到位，就在这个帖子里记录下每次学到的东西吧~ 最大堆&#x2F;优先队列C++提供了priority_queue，默认是最大堆 TODO依稀记得最大堆只需要使用数组就可以完成了，后面复习下数据结构！ 自定义排序priority_queue的默认排序规则是最大堆，当我们需要一个最小堆时，就需要一个自定义的排序对则，仿函数和lambda函数都可以完成这一人物。 1234567struct Compare &#123; bool operator()(int a, int b) &#123; return a &gt; b; &#125;&#125;;std::priority_queue&lt;int, std::vector&lt;int&gt;, Compare&gt; minHeap; 12345auto compare = [](int a, int b) &#123; return a &gt; b; &#125;;std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(compare)&gt; minHeap(compare); 但是其实一直不明白的是，为什么return a &gt; b就是从小按大排序呢。其实可以把C++的排序，按照优先级去理解。当compare(a,b) &#x3D; true时，那么a的优先级就是小于b的。 比如std::sort默认就是把优先级高的往后排，对于正常的int而言，且没有重载运算符，当 a &lt; b时，那么默认的int排序规则就会返回true，b的优先级就更高，那调用std::sort的时候，就会把b放在a后面，最后结果就是由小到大。 同理，priority_queue默认就是把优先级高的放在堆顶，我们重载的compare，当a的值小于b时，那么返回false，则会认为a的优先级比b高，那就会把a放在堆顶，因此就变成了最小堆。 对象构造之前堆std::sort做排序的时候，仿函数和lambda函数完全一致，但是突然发现，对于上面的优先队列而言，好像并不这么一回事。 12template &lt;typename T, typename Container = std::vector&lt;T&gt;, typename Compare = std::less&lt;typename Container::value_type&gt;&gt;class priority_queue; 这是优先队列的定义，注意这是一个模板，那注定，构造的时候，传入的模板的第三个参数，需要时一个类型，而非对象。 所以compare &#x3D; [](int a, int b) 定义了一个对象，但是传入模板的时候，需要decltype(compare)获取它的具体类型。而仿函数，本身就是一个struct，有明确的类型，直接可以作为模板参数。 此外，可以发现初始化时，lambda还需要多传一个lambda对象进去，而仿函数不用。这是因为priority_queue需要一个compare实例，仿函数有默认构造函数，可以直接构造；但lambda没有，所以就只能传一个进去。"},{"title":"My Trick on Windows & Linux","path":"/2024/12/23/trick/","content":"这里记录一下自己在鼓捣自己电脑的时候，成功试验并觉得有效提升使用体验的一些小技巧吧~ Windows终端windows的cmd命令，可以说是非常的让人无语了，和linux完全的不兼容。而且学习成本非常的高昂。太扯淡啦！&#x1F4A9; 后面推出的WT（windows terminal），虽然在原cmd的基础上增添了很多东西，但是还是完全没法用的程度。继续无语&#x3D;&#x3D;&#x3D; &#x1F33F;。 幸好我们拥有git！安装完git后，我们会直接得到一个git bash。提供了非常接近bash的环境！狂喜！那么，我们可以直接在WT中，设置默认打开的终端环境，这样体验感直接up up! &#x1F44F; 同理，vscode中也可以如此设置~ 快捷键WT的使用频率一高，不想在桌面增加快捷方式，又想要一个快捷的打开方式，该怎么办呢？很自然的想法就是，设置一个快捷键，类似ubuntu的 ctrl + shift + T 一键打开终端。 个人了解的windows的快捷键添加方式有两种： exe发送快捷方式到桌面，右键，巴拉巴拉找到一个快捷键（记不清了） autohotkey！新发现的很不错的软件，本人现在的快捷键也是通过此来配置的 autohotkey官网可直接安装，仅需3M。接下来就是简单了解下它的脚本规则，快捷键的设置规则就是： 1234hotkey ::&#123; Run app&#125; 当然这个软件应当是还可以做很多事情，但是哥们只看了几秒快捷键的设置，只知道这些。 本人目前设置了两个快捷键，已爽翻： Ctrl + Shift + W -&gt; WT Ctrl + Shift + T -&gt; WSL 最后一步将配置文件放置到C:\\Users\\{user_name}\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup中，即可开机自启，大功告成！ gcc &amp; clang 安装1pacman -Q 查看安装了哪些包 1pacman -S &#123;package name&#125; 安装指定的包 1pacman -Ss 列出所有可用的包（包括未安装的） 1pacman -Qi &#123;package_name&#125; 查看某个包的详细信息 1pacman -Syu 更新包管理器 本人用mysy2构建了全套的C++编译工具，包括clang、clangd、gcc、make、cmake。爽歪歪。本条命令用来安装clangd 1pacman -S mingw-w64-ucrt-x86_64-clang-tools-extra 搭配clang插件，vscode写C++的体验感再一次提升了。clion请直接退休好吗。值得一提的，哥们曾在wsl也搞过clangd，但是启动后的几秒就会直接崩掉，且没有找到解决办法。也许是分配给wsl的内存太少了？不过现在在windows下的体验还是非常的顶呱呱的。嘻。"},{"title":"LeetCode刷题记录","path":"/2024/12/21/leetcode/","content":"记录刷题的每一天！感受逐渐变强的自己！ 环境配置VsCode + labuladong vscodevscode的安装无需多言了 leetcode 插件在leetcode网站上刷题体验感实际上是很一般的。主要是补全差劲；字体难看；等等等。所有就有了leetcode刷题插件的诞生。可以自由的在vscode里读题、写代码、提交代码。 但很不好的是，它给你生成的代码内容是不包含头文件的，会导致vscode报错飘红，体验感依旧不足够高。 labuladong的算法插件labuladong大佬在leetcode插件上进一步开发的。属于是弥补了原插件的许多不足之处。具体的说法和细则，请看官网。体验感已经是本人能找到的非常棒的了。不过还有缺点就是，不能直接构造main函数，构建测试用例，使得可以直接开始debug。 另外仍需注意，该插件只能用cookie登录。需要在网络控制台中，抓一个带有cookie字样的包然后右键， Copy as cURL (bash)，随后开启新世界大门！ 547 省份数量老听并查集的大名，但是一直没有学习过，直接拿上547题来练手。 并查集学过一遍之后，并查集应该是要用数组表示的树？很吊的。 反正啥操作前都加个find_parent就对了！ 构造函数一个并查集可以有n个节点，初始化时，各个节点都先自己指向自己，每个节点都是一个单独的集合。 123456UnionFind(int n)&#123; array_.resize(n); for(int i = 0 ; i &lt; n;i++)&#123; array_[i] = i; // 并查集自己先指向自己 &#125;&#125; 合并函数合并函数就是一个集合的父节点，指向另一个集合的父节点，这样他们就合并成了一撮，变成了同一个集合。 1234void to_union(int child, int parent)&#123; // ! 注意，并查集的操作，是对父节点的操作，一切要以父节点为准 array_[find_parent(child)] = find_parent(parent);&#125; 其他的合并方式假如union(1,2)、union(2,3)、union(3,4)，这样循环的调用，那节点之间的指向关系，明显是一个链状的，当然这是最坏的情况，有没有什么好的压缩的方法呢？ 其实就是希望合并之后，树的高度尽可能的矮嘛，那可以额外的增加一个数组，记录每个集合的高度，合并的时候，矮的指向高的，不就不会导致高度过分的增加了嘛。 当然，更佳的一个做法是，用上路径压缩。 寻根函数（带路径压缩）讲解视频 12345678910int find_parent(int i)&#123; // 视频中所述，并查集要注意 !路径压缩! 不然一个集合里的排布是一长串，复杂度不是最优 if (array_[i] == i)&#123; return i; // 已经找到根节点了 &#125;else&#123; array_[i] = find_parent(array_[i]); // 这里就是在做路径压缩 return array_[i]; &#125;&#125; 一共有多少集合呢反正我是用一个集合，但是感觉实际是很愚蠢的！ 1234567int get_num()&#123; unordered_set&lt;int&gt; statistic_set; for (int i = 0; i &lt; array_.size(); i++)&#123; statistic_set.insert(find_parent(i)); &#125; return statistic_set.size();&#125; 可以在每次合并，就将合并次数++！那集合的数量，不就是 size - merge_count吗！ 不解但是并查集的时间复杂度咋算呢？回头再学习学习吧。 链表题目21.合并两个有序链表 &amp;&amp; 86.分隔链表主要涉及到的技巧是： dummy虚拟头结点的使用，可以有效的避免很多的边界条件判断 如果是把原链表重新构造成一个新的链表，那总是需要断开原链表之间的连接关系，欲断不断，就会导致最后的链有可能成环，一定要注意！ 23.合并k个有序链表这题一看有点蒙蔽，这怎么比节点们的大小，然后瞅一眼题解，竟然是已经遗忘已久的优先队列，惭愧惭愧，彻底的还给老师了。这题显然也是没有涉及new操作的，把原链表拼成新链表的操作，类似上面提到的，要断开每个节点之间的联系。当然这题可以不断，但是还是保持这个好习惯的好。 然后值得记录的是，C++优先队列的初始化，记录在同级的C++博客中了。 19.删除链表的倒数第N个节点主要是设计到了寻找倒数第N个节点的技巧，使用快慢指针。就是一个指针先走N步，然后另一个指针再开始走，当快指针走到头的时候，慢指针就走到了倒数第N个节点。 12345678910111213141516// 返回链表的倒数第 k 个节点ListNode* findFromEnd(ListNode* head, int k) &#123; ListNode* p_fast = head; // p_fast 先走 k 步 for (int i = 0; i &lt; k; i++) &#123; p_fast = p_fast -&gt; next; &#125; ListNode* p_slow = head; // p_fast 和 p_slow 同时走 n - k 步 while (p_fast != nullptr) &#123; p_slow = p_slow -&gt; next; p_fast = p_fast -&gt; next; &#125; // p_slow 现在指向第 n - k + 1 个节点，即倒数第 k 个节点 return p_slow;&#125; 注意的是，当p_fast指向链表的尾部的nullptr时，p_slow指向的才是倒数第k个节点。当p_fast指向链表的最后一个节点时，p_slow指向的是倒数第k+1个节点。 比较极限的情况是，链表要删除第一个节点，但这时候第一个节点前面也没有节点了，此时就需要dummy节点了，在链表最开始插上一个头结点，这样就可以避免很多的边界条件判断。当你使用了dummy节点后，返回值一般是dummy-&gt;next，本题可不能看到说返回头节点，就return head，会出错。 876.链表的中间结点这题思路倒是很简单，一快一慢就好。主要是停止的边界条件怎么设置。 12345678910ListNode* middleNode(ListNode* head) &#123; ListNode *p_slow = head, *p_fast = head; // !仔细思考下这个边界条件的设置 // while (p_fast-&gt;next != nullptr and p_fast != nullptr) &#123; while (p_fast != nullptr and p_fast-&gt;next != nullptr) &#123; p_slow = p_slow-&gt;next; p_fast = p_fast-&gt;next-&gt;next; &#125; return p_slow; &#125; 快指针每次移动两步，那什么是否停止移动呢？就是当快指针不能再往下移动了，即快指针不为空，或者快指针的下个元素不空。 需要注意一点，p_fast != nullptr 要放在前面先判断，否则p_fast == nullptr时，执行p_fast-&gt;next != nullptr铁会出现问题。 142.环形链表链表如果有环，典型做法就是，快慢指针，如果相遇了就证明有环。 1234567while (p_fast != nullptr and p_fast-&gt;next != nullptr) &#123; p_slow = p_slow-&gt;next; p_fast = p_fast-&gt;next-&gt;next; if (p_slow == p_fast) &#123; break; &#125;&#125; 就两种情况退出循环: 无环，fast走到尽头，触发while条件，退出 有环，相交退出 可以发现，即使长度为1的有环无环链表，这个代码都能正常工作，所以其实无需什么边界情况处理。对于此题，要找到入口处的节点，需要一些数学证明： 我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步 fast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。 这里是整数倍哦。 假设相遇点距环的起点的距离为 m，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。 巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点 沿用此思路，即可解出此题 160.相交链表本人的直接想法就是，先遍历一遍，找到他们的头距离差距，然后直接对齐，顺序往后移动就好~ 123456789101112131415161718192021222324252627282930ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; int len_a = 0, len_b = 0; ListNode *pa = headA, *pb = headB; while (pa != nullptr) &#123; pa = pa-&gt;next; len_a++; &#125; while (pb != nullptr) &#123; pb = pb-&gt;next; len_b++; &#125; pa = headA, pb = headB; if (len_a &gt; len_b) &#123; int delta_len = len_a - len_b; for (int i = 0; i &lt; delta_len; i++) &#123; pa = pa-&gt;next; &#125; &#125; else &#123; int delta_len = len_b - len_a; for (int i = 0; i &lt; delta_len; i++) &#123; pb = pb-&gt;next; &#125; &#125; while (pa != pb) &#123; pa = pa-&gt;next; pb = pb-&gt;next; &#125; return pa;&#125; labuladong提供了两个更奇思妙想的方法： 第一条遍历完去走第二条，第而条遍历完去走第一条，当他们相遇的时候，就成了 公链的最后一个节点指向其中一条的起点，问题就变成了，寻找环的起点，即142题 数组题目26.删除有序数组中的重复项这题一开始的想法是，一个指针指向前面，一个指针指向后面，然后遇到重复的就swap一下，但是这样搞完之后就不有序了，想了半天没有想到解决办法。可恶啊，被一道easy题给拿下了。 思路同样是快慢指针，但是这个不同于链表快慢指针是慢指针的两倍速，但是本题，slow是待在后方，维护着迄今为止的正确的结果，fast是在前面探路的，他们的速度差距是由数组元素的排布造成的。 本人的笨笨代码，实在是太蠢了。 index不用非要从1开始 也不用记录fast走过的上一个值，只需要比较fast和slow的值，因为slow的元素必定是最新的不重复的那个值 12345678910111213141516int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int slow = 1, fast = 1; int size = nums.size(); int last_value = nums[0]; while(fast &lt; size)&#123; if(nums[fast] == last_value)&#123; fast++; &#125;else &#123; nums[slow] = nums[fast]; last_value = nums[fast]; fast++; slow++; &#125; &#125; return slow;&#125; 标准答案 12345678910111213141516int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) &#123; return 0; &#125; int slow = 0, fast = 0; while (fast &lt; nums.size()) &#123; if (nums[fast] != nums[slow]) &#123; slow++; // 维护 nums[0..slow] 无重复 nums[slow] = nums[fast]; &#125; fast++; &#125; // 数组长度为索引 + 1 return slow + 1;&#125; 27.移除数组和本题同理 283.移动零我简直是个智障吧，这也没想出来。其实只需要两步： 按照27题的思路，删除所有为0的元素 把末尾的元素，全部置为0 比较有迷惑性的是这道题的表述，他说把为0的元素移动到最后。这个移动就很灵性，让我以为必须是什么元素要交换一下，所以该怎么遍历，才能把0都给换到后面呢。所以苦思冥想了半天，还是太死板了…… 但是答案就是先删再赋值。虽然简单，但实在是巧妙呀。 数组题目，凡是涉及到原地修改、保持原来元素的相对顺序 等要求，就往快慢指针这里想一想。 左右指针基本上有两种形式： 左右指针向中间收缩 左右指针向两边扩散 167.两数之和这道题就是典型的向中间收缩的左右指针。思路并不困难，但是有继续引申的nSum问题，后面得好好继续研究下。 1234567891011121314vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int left = 0, right = numbers.size() - 1; while (left &lt; right) &#123; int sum = numbers[left] + numbers[right]; if (sum &lt; target) &#123; left++; &#125; else if (sum &gt; target) &#123; right--; &#125; else if (sum == target) &#123; return &#123;left + 1, right + 1&#125;; &#125; &#125; return &#123;0, 0&#125;;&#125; 5.最长回文子串这道题是典型的向两边扩散的左右指针，一开始确实也没啥思路，看了答案才豁然开朗。 回文串分为奇数和偶数，奇数时有一个中心点，偶数时有两个中心点。首先给出一个有中心点向两边扩散，寻找最长回文串的代码。 12345678string huiwenStr(string&amp; str, int left, int right) &#123; while (left &gt;= 0 and right &lt; str.size() and str[left] == str[right]) &#123; left--; right++; &#125; // !notice 注意当它停止的时候，left指向了回文串的两边，所以要left + 1 return str.substr(left + 1, right - left - 1);&#125; 代码固定需要传入两个中心点，left = right 就是奇数串，left + 1 = right 就是偶数串。然后需要注意边界控制，left、right应该是一个正确的索引，不能越界，所以是left &gt;= 0 and right &lt; str.size()，之前自己写成left &gt; 0显然是有问题的 然后需要注意，while循环需要保证回文串的特性才能继续循环，即tr[left] == str[right]，以及最后返回的子串，left + 1才是回文串的起点，长度为right - left - 1 最后仅需要遍历每一个可能的中心点，就可以找到最长的回文串 123456789101112131415string longestPalindrome(string s) &#123; string max_str = &quot;&quot;; for (int i = 0; i &lt; s.size(); i++) &#123; // 以i为中心的奇数串 string str1 = huiwenStr(s, i, i); string str2 = huiwenStr(s, i, i + 1); if (str1.size() &gt; max_str.size()) &#123; max_str = str1; &#125; if (str2.size() &gt; max_str.size()) &#123; max_str = str2; &#125; &#125; return max_str;&#125; 二分查找今天，我要学会自己做二分搜索！ 首先，我们要明确，二分搜索的区间可以分为左闭右闭[left, right],也可以分为左闭右开[left, right)，但是哥们独爱左闭右闭，所以后续所有的写法都是左闭右闭。 普通二分搜索1234567891011121314int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; // target比中间值大，那么就要从右边的区间找 left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return -1;&#125; 左闭右闭体现在初始化的时候，如果right = nums.size()-1，那么nums[right]就是可以直接访问的，那么右边区间就是闭合的，就是左闭右闭。 while循环何时停止呢？当然是[left, right]这个区间不成立的时候，即left = right + 1当nums[mid] 不符合target时，那就要调整区间的范围了。调整的幅度就是在mid左右，设置为新的左&#x2F;右边界 左&#x2F;右边界的二分搜索 &amp; 34.在排序数组中查找元素的第一个和最后一个位置之前都没有想过，二分搜索竟然还能这么玩。 123456789101112131415161718192021int left_bound(vector&lt;int&gt;&amp; nums, int target) &#123; // 可以自动适配size = 0 的情况，无需额外适配 int res1; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; right = mid - 1; &#125; else if (nums[mid] &gt;= target) &#123; right = mid - 1; &#125; else if (nums[mid] &lt;= target) &#123; left = mid + 1; &#125; &#125; if (left &gt;= nums.size()) &#123; res1 = -1; &#125; else &#123; res1 = nums[left] == target ? left : -1; &#125; return res1;&#125; 此二分搜索大部分和普通的是一样的，但是当nums[mid] == target时，就有区别了。因为我们要找左边的边界，那么就更新区间右边界，继续去找。 本部分我一开始的疑问是，如果此时的mid已经是最左边的target元素，那就调用了right &#x3D; mid - 1，去再左边找元素了，那岂不是就再也找不到这个target元素了吗？ debug了一遍才发现，如果此时的mid已经是最左边的target元素，那么继续找下去，left和right一定会走到：left = right = mid - 1！然后，进入分支left = (left + right) / 2 + 1 = mid -1 + 1 = mid，可以发现，当退出while后，left恰巧又指向了最左边的target元素，很巧妙，很神奇吧。太屌了。 还有个区别是，当数组中不存在target元素时，需要额外的边界控制： target大于数组的最大值，很明显，这种情况，left最后会指向 nums.size()，发生了越界，所以需要特判，越界了返回-1 target的大小是包含在数组的上下界里的，这种情况，left会指向大于 target 的最小索引，所以需要判断nums[left] == target，不等于则是没有找到 1234567891011121314151617181920int right_bound(vector&lt;int&gt;&amp; nums, int target) &#123; int res2; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt;= target) &#123; right = mid - 1; &#125; else if (nums[mid] &lt;= target) &#123; left = mid + 1; &#125; &#125; if (right &lt; 0) &#123; res2 = -1; &#125; else &#123; res2 = nums[right] == target ? right : -1; &#125; return res2;&#125; 寻找右边界一样的道理，只不过 nums[mid] == target时，就更新区间左边界，继续去找。 right有可能指向-1，数组越界，需额外判断"},{"title":"Hello World","path":"/2024/12/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]