[{"title":"协程0","path":"/2025/05/18/fiber0/","content":"在尝试自己造个最最简单的协程库，记录一下~ 神奇的现象1234567891011121314#include &lt;sys/ucontext.h&gt;#include &lt;ucontext.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; ucontext_t uxt; getcontext(&amp;uxt); printf(&quot;hello world &quot;); sleep(1); setcontext(&amp;uxt); return 0;&#125; 这段代码的"},{"title":"内存泄漏","path":"/2025/04/23/memory_leak/","content":"研究一下~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;vector&gt;// 基类：图形对象class Shape &#123;public: virtual void draw() = 0; // 缺少虚析构函数 -&gt; 泄漏点1&#125;;// 派生类：圆形class Circle : public Shape &#123;private: double* center; // 动态分配的圆心坐标 -&gt; 泄漏点2 double radius;public: Circle(double x, double y, double r) : radius(r) &#123; center = new double[2]; center[0] = x; center[1] = y; &#125; void draw() override &#123; std::cout &lt;&lt; &quot;Circle at (&quot; &lt;&lt; center[0] &lt;&lt; &quot;, &quot; &lt;&lt; center[1] &lt;&lt; &quot;) with radius &quot; &lt;&lt; radius &lt;&lt; &quot; &quot;; &#125; // 缺少析构函数 -&gt; 泄漏点2&#125;;// 图形管理器class ShapeManager &#123;private: std::vector&lt;Shape*&gt; shapes; // 容器存储裸指针 -&gt; 泄漏点3public: void addShape(Shape* shape) &#123; shapes.push_back(shape); &#125; void drawAll() &#123; for (auto s : shapes) s-&gt;draw(); &#125; // 缺少析构函数 -&gt; 泄漏点3&#125;;void process() &#123; ShapeManager manager; for (int i = 0; i &lt; 5; ++i) &#123; manager.addShape(new Circle(i, i, i)); // 直接new -&gt; 泄漏点4 &#125; manager.drawAll(); // 模拟异常场景 if (true) &#123; // 假设某个条件触发异常 throw std::runtime_error(&quot;Something went wrong&quot;); &#125;&#125;int main() &#123; try &#123; process(); &#125; catch (...) &#123; std::cout &lt;&lt; &quot;Exception handled &quot;; &#125; // 所有动态分配的Shape对象均未释放 -&gt; 泄漏点5 return 0;&#125; 让deepseek给生成了一段，可以说是四处漏的代码了 Valgrind12345678910111213141516171819Exception handled==44985== ==44985== HEAP SUMMARY:==44985== in use at exit: 200 bytes in 10 blocks==44985== total heap usage: 18 allocs, 8 frees, 74,237 bytes allocated==44985== ==44985== 200 (120 direct, 80 indirect) bytes in 5 blocks are definitely lost in loss record 2 of 2==44985== at 0x4849013: operator new(unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)==44985== by 0x1092CB: process() (src/memort_leak.cpp:46)==44985== by 0x1093D3: main (src/memort_leak.cpp:58)==44985== ==44985== LEAK SUMMARY:==44985== definitely lost: 120 bytes in 5 blocks==44985== indirectly lost: 80 bytes in 5 blocks==44985== possibly lost: 0 bytes in 0 blocks==44985== still reachable: 0 bytes in 0 blocks==44985== suppressed: 0 bytes in 0 blocks==44985== ==44985== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) ASAN12345678910111213141516==46753==ERROR: LeakSanitizer: detected memory leaksDirect leak of 120 byte(s) in 5 object(s) allocated from: #0 0x7f30e36161e7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99 #1 0x56133b24d5bc in process() /home/xuechen/Code/C++/learn/src/memory_leak.cpp:46 #2 0x56133b24d6d6 in main /home/xuechen/Code/C++/learn/src/memory_leak.cpp:58 #3 0x7f30e302dd8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58Indirect leak of 80 byte(s) in 5 object(s) allocated from: #0 0x7f30e3616357 in operator new[](unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:102 #1 0x56133b24d8f0 in Circle::Circle(double, double, double) /home/xuechen/Code/C++/learn/src/memory_leak.cpp:18 #2 0x56133b24d604 in process() /home/xuechen/Code/C++/learn/src/memory_leak.cpp:46 #3 0x56133b24d6d6 in main /home/xuechen/Code/C++/learn/src/memory_leak.cpp:58 #4 0x7f30e302dd8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58SUMMARY: AddressSanitizer: 200 byte(s) leaked in 10 allocation(s). 简单的手动重载new delete"},{"title":"十大排序","path":"/2025/04/12/sort/","content":"排序可是基本功 前言不同的排序算法，常在以下几个方面进行对比，有：时间复杂度、空间复杂度、是否稳定排序、是否需要额外空间。以及最恶劣的情况下，时间复杂度。 选择排序选择排序的思路非常直白，就是第一下就会想到的的实现思路：从第一个未排序的位置向后寻找最小值的位置，然后和当前第一个未排序的元素交换位置。 选择排序有个比较明显的问题，就是排序的稳定性。比如目前有一个序列：2&#39; 2&#39;&#39; 2&#39;&#39;&#39; 1&#39;，那选择排序完成一次交换后，序列变为1&#39; 2&#39;&#39; 2&#39;&#39;&#39; 2&#39;， 可见，2元素之间的排布顺序发生了改变，这就是选择排序的不稳定性。 时空复杂度：$O(N^2)$， 具体操作次数 $\\frac{n^2}{2}$ 无论原数组是否有序，不影响选择排序执行的次数 &lt;-思考记住一下 12345678910111213vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; int min_index = i; for (int j = i; j &lt; n; j++) &#123; if (nums[min_index] &gt; nums[j]) &#123; min_index = j; &#125; &#125; std::swap(nums[min_index], nums[i]); &#125; return nums;&#125; 冒泡排序冒泡排序实际上是对插入排序增加稳定性的优化，具体的优化思路可以沿着下文的方式进行思考： 在插入排序上增加稳定性：上文我们知道，swap这个交换操作是破坏了稳定性的罪魁祸首。为了保证选择排序的稳定性，可以将交换操作，转换为了依次的向右平移【第一个未排序元素，最小元素的前一个元素】，随后在空出的位置插入。这一操作显然增加了排序的操作次数，时间复杂度仍是$O(N^2)$ 进一步优化：既然你要先遍历，然后找最小值，然后再换。那能不能找完之后，最小值就已经被放在了最开头的位置嘞。答案是可以的，我们从后向前遍历，如果发现逆序对儿，就交换顺序。 1234567891011vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; for (int j = n - 1; j &gt; i; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; std::swap(nums[j], nums[j - 1]); &#125; &#125; &#125; return nums;&#125; 然后，我们就得到了冒泡排序，可以看到，由于我们只交换相邻的逆序对儿，不会去碰值相同的元素，所以这个算法是稳定排序。 leetcode912题 11&#x2F;21通过 冒泡排序的提前终止如果我们发现，一次遍历没有任何的逆序对交换，那说明这个数组已经被排序完成了，即可立即退出当前的循环，返回结果。 12345678910111213141516vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; bool no_swap = true; for (int j = n - 1; j &gt; i; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; std::swap(nums[j], nums[j - 1]); no_swap = false; &#125; &#125; if(no_swap)&#123; // 没有逆序对交换，已经有序 break; &#125; &#125; return nums;&#125; leetcode912题 10&#x2F;21通过 插入排序插入排序的思路和前面的选择排序，正好相反。插入排序选择，将nums[sortedIndex]插入在 nums[0..sortedIndex-1] 这个部分有序的数组中，而插入的方法则类似于冒泡排序的不断交换 1234567891011121314vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; int sort_index = i; for (int j = sort_index; j &gt; 0; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; std::swap(nums[j], nums[j - 1]); &#125; else &#123; // 因为前面已经有序了，如果当前就不需要交换了，那这部分就已经有序了，直接break break; &#125; &#125; &#125; return nums;&#125; 很值得注意的一点就是，这个else非常精髓。当你像冒泡排序一样的将nums[sortedIndex]向前不断交换逆序对，如果当前逆序已经不需要被交换的时候，而插入排序始终保持nums[0..sortedIndex-1]这个部分有序，那么前面的数组也已经有序了，那可以直接跳出当前的内部for循环。这其实就是等于冒泡排序的提前终止。 那么很容易就能得到一个结论，当数组的初始有序度越高，插入排序的内层for循环几乎不会被执行几次，插入排序的效率越高，时间效率近似$O(N)$。当然，当数组完全逆序的时候，时间复杂度就等于$O(N^2)$ leetcode912题 12&#x2F;21通过 希尔排序希尔排序是插入排序的直接优化。但是很抽象，哥们回头理解好了再写 快速排序快排作为最经典的排序算法，其本质上非常类似于树的前序遍历，其主要过程有： 在 nums 数组中任意选择一个元素作为切分元素 pivot（一般选择第一个元素） 对数组中的元素进行若干交换操作，将小于 pivot 的元素放到 pivot 的左边，大于 pivot 的元素放到 pivot 的右边（换句话说，其实就是将 pivot 这一个元素排好序） 递归地对 pivot 左边的数组和右边的数组重复上述步骤：寻找新的切分元素，然后交换元素，使得切分元素左侧都元素都比它小，右侧都元素都比它大（换句话说，其实就是递归的去把 pivot 左右两侧的其他元素排好序 递归地重复上述操作，直到所有元素都放到正确的位置 这里有一个详细的示意图： 12345 [4, 1, 7, 2, 5, 3, 6] / \\ [2, 1, 3] [4] [7, 5, 6] / \\ / \\[1] [2] [3] [5] [6] [7] 123456789101112131415161718192021222324252627282930313233vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; quickSort(nums, 0, nums.size() - 1); return nums;&#125;void quickSort(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int pivot = partition(nums, left, right); quickSort(nums, left, pivot - 1); quickSort(nums, pivot + 1, right);&#125;int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int pivot = left; // 第0个元素作为分割 int i = left + 1, j = right; // 注意，这个是左闭右闭 while (true) &#123; // i 找 &gt;= pivot 的元素 while (i &lt;= j &amp;&amp; nums[i] &lt;= nums[pivot]) i++; // j 找 &lt;= pivot 的元素 while (i &lt;= j &amp;&amp; nums[j] &gt;= nums[pivot]) j--; if (i &gt;= j) break; swap(nums[i], nums[j]); &#125; // 此时 nums[j] &lt;= pivot，确保交换正确 swap(nums[pivot], nums[j]); return j;&#125; 首先需要注意这个partition函数内部的一些细节，这个有点子二分搜索的感觉。 注意区间是左闭右闭 注意nums[i] &lt;= nums[pivot]，这个&#x3D;比较重要，否则无法处理重复元素 那么，问题就要来了，快排是稳定排序么。 为了保证极端情况下的性能，可以初始时打乱 123456789void shuffle(vector&lt;int&gt;&amp; nums) &#123; srand((unsigned)time(NULL)); int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; // 生成 [i, n - 1] 的随机数 int r = i + rand() % (n - i); swap(nums[i], nums[r]); &#125;&#125; 归并排序归并排序的方向其实就像快速排序的反方向一样。快速排序是先把一个元素排好序，然后再把左右两边剩下的元素排好序；归并排序是先把数组分成两半，把子数组排好序后，整体数组就排好序了。 12345 [3， 2， 4， 1] / \\ [3， 1] [4， 1] / \\ / \\[2] [2] [4] [1] 1234567891011121314151617181920212223242526272829303132333435363738vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; sort(nums, 0, nums.size() - 1); return nums;&#125;void sort(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left == right) &#123; // 根节点，只有一个元素，无需排序 return; &#125; int mid = left + (right - left) / 2; sort(nums, left, mid); sort(nums, mid + 1, right); merge(nums, left, mid, right);&#125;void merge(vector&lt;int&gt;&amp; nums, int left, int mid, int right) &#123; vector&lt;int&gt; temp(nums.begin() + left, nums.begin() + right + 1); // 两个左闭右闭区间的起点是left 和 mid +1，就是为了索引temp里的元素，向左偏移了 int pl = 0, pr = mid - left + 1; int i = left; while (pl &lt;= mid - left &amp;&amp; pr &lt;= right - left) &#123; if (temp[pl] &lt;= temp[pr]) &#123; nums[i++] = temp[pl++]; &#125; else &#123; nums[i++] = temp[pr++]; &#125; &#125; while (pl &lt;= mid - left) &#123; nums[i++] = temp[pl++]; &#125; while (pr &lt;= right - left) &#123; nums[i++] = temp[pr++]; &#125;&#125; 这里有几点需要注意： pr == right + 1，注意是right + 1 temp[pl] &gt; temp[pr]，注意是temp数组去比较 可以声明static变量，否则测试会超时 堆排序二叉堆拥有一个性质：任意节点的值，都比它的左节点和右节点大&#x2F;小，称为最大&#x2F;小堆，且插入和删除元素的时间复杂度均为$O(LogN)$。堆排序则是二叉堆的基础上产生，$O(NLogN)$ 下面是一个最小堆的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class MinHeap &#123;public: MinHeap() &#123; &#125; void push(int val) &#123; vec_.push_back(val); size_++; siftUp(size_ - 1); &#125; void pop() &#123; std::swap(vec_[0], vec_[size_ - 1]); vec_.pop_back(); // 如果你前面push用的push back，那这里一定要释放 size_--; siftDown(0); &#125; int top() &#123; return vec_[0]; &#125;private: std::vector&lt;int&gt; vec_; int size_; void siftUp(int index) &#123; // 注意index &gt;0 while (index &gt; 0 &amp;&amp; vec_[index] &lt; vec_[(index - 1) / 2]) &#123; std::swap(vec_[index], vec_[(index - 1) / 2]); index = (index - 1) / 2; // 记得要更新索引 &#125; &#125; void siftDown(int index) &#123; // 这个判断条件也要注意，左节点要存在 while (2 * index + 1 &lt;= size_ - 1) &#123; int left = 2 * index + 1; int right = 2 * index + 2; // 找出左右最小的那个，然后和它比较 int small_index = left; if (right &lt;= size_ - 1 &amp;&amp; vec_[right] &lt; vec_[left]) &#123; small_index = right; &#125; if (vec_[index] &gt; vec_[small_index]) &#123; std::swap(vec_[index], vec_[small_index]); index = small_index; &#125; else &#123; break; &#125; &#125; &#125;&#125;; 二叉堆本质是一颗完全二叉树，通过数组的形式进行模拟，并且父节点和子节点的index有特殊关系。插入和删除均为父子节点相互倒腾的情况。 这段代码中，要注意的点有： 数组索引从0开始，父节点是(index - 1) / 2, 左子节点是2 * index + 1，右子节点是2 * index + 2 要注意size_和元素下标天然的差一，所以有siftUp(size_ - 1) 要注意下沉操作中，要找到左右子节点中最小的那一个，然后再换，随便找一个节点然后换的话，可能会导致堆的性质不被满足；需要注意while循环的条件，是左节点存在，但比较左右子节点的时候，需要额外判断右节点是否存在"},{"title":"函数栈帧","path":"/2025/03/30/stack/","content":"可以说是很基础的部分了，大二的时候还记得挺清楚的，但现在忘的差不多了。在理解无栈&#x2F;有栈协程的时候，感觉还是很需要这部分知识的 从汇编的角度理解首先，有这么几个前置的点， 栈的大小，在编译期间就可以确定，只在调用的时候分配一次。不存在一个栈的空间随着运行，动态的增长 栈是由高地址向低地址逐渐生长的 栈底指针叫ebp（base）, 栈顶指针叫esp（stack） 12345678910int add(int a, int b) &#123; int sum = a + b; return sum;&#125;int main() &#123; int x = 5, y = 3; int result = add(x, y); return 0;&#125; 以这段代码为例，其汇编大抵是这样的： 12345678910111213141516171819202122232425262728add(int, int): pushq %rbp # 保存调用者基址 movq %rsp, %rbp # 设置新基址 subq $16, %rsp # 分配栈空间 movl %edi, -4(%rbp) # 参数 a 存入栈 movl %esi, -8(%rbp) # 参数 b 存入栈 movl -4(%rbp), %edx addl -8(%rbp), %edx # a + b movl %edx, -12(%rbp) # sum = a + b movl -12(%rbp), %eax # 返回值存入 eax leave # 恢复栈指针和基址 retmain: pushq %rbp movq %rsp, %rbp subq $16, %rsp ; 分配 16 字节栈空间（对齐到 16 字节边界） movl $5, -4(%rbp) ; x = 5 movl $3, -8(%rbp) ; y = 3 movl -8(%rbp), %edx ; 加载 y 到 edx movl -4(%rbp), %eax ; 加载 x 到 eax movl %edx, %esi ; 参数 b = y movl %eax, %edi ; 参数 a = x call add ; 调用 add movl %eax, -12(%rbp) ; result = 返回值 movl $0, %eax leave ret 内存布局按时间顺序大抵是这样的： 进入main函数12345678910111213+------------------------+ 高地址 (栈底方向)| 返回地址 | ← RBP + 0x8 main 函数入口时保存旧 RBP+------------------------+| 保存的 RBP | ← RBP+------------------------+| x=5 (RBP-4) | +------------------------+| y=3 (RBP-8) |+------------------------+| result (未初始化, RBP-12) |+------------------------+| 填充 (4 字节) | ← RBP-16 (RSP 初始位置)+------------------------+ 可以看到，给main函数预分配了16字节的空间 调用add函数前1234567891011121314151617+------------------------+| 返回地址 (main) | ← RBP + 0x8+------------------------+| 保存的 RBP | ← RBP+------------------------+| x=5 (RBP-4) |+------------------------+| y=3 (RBP-8) |+------------------------+| result (RBP-12) |+------------------------+| 填充 (4 字节) | ← RSP+0x10+------------------------+| a=5 (参数1) | ← RSP+0x8+------------------------+| b=3 (参数2) | ← RSP+------------------------+ ← 当前 RSP (call 前) 这里把函数的参数压栈 进入add函数123456789+------------------------+| 返回地址 (main) | ← RBP + 0x8 (add 的 RBP)+------------------------+| 保存的 RBP (main 的 RBP) | ← RBP (当前基址)+------------------------+| sum=8 (RBP-4) |+------------------------+| 填充 (12 字节) | ← RSP+------------------------+ 返回到main函数12345678910111213+------------------------+| 返回地址 (操作系统) | ← RBP + 0x8+------------------------+| 保存的 RBP (原调用者) | ← RBP+------------------------+| x=5 (RBP-4) |+------------------------+| y=3 (RBP-8) |+------------------------+| result=8 (RBP-12) |+------------------------+| 填充 (4 字节) | ← RSP+------------------------+ 这里很有可能是有一些纰漏的，等哥们后面再仔细瞅瞅 尾递归其实也不一定是递归，就是这种优化可以产生于：调用是函数体中的最后一个操作的情况下。 核心的优化是在于，call指令被替换成了jmp指令，会复用旧的栈帧"},{"title":"Linux命令行学习","path":"/2025/03/21/bash/","content":"Linux命令行可太强大了，但是这篇博客不是很想介绍每个命令的作用，俺想用不同的场景介绍怎样组合命令才能达到我们想要的效果 统计一个目录下有多少文件把一个目录下，所有的cpp文件用clang-format格式化1find . -name &#x27;*.cpp&#x27; -o -name &#x27;*.h&#x27; | xargs clang-format -i 主要涉及到两个命令： find"},{"title":"Go学习记录","path":"/2025/03/15/go/","content":"最近发现有很多非常著名的项目都是Go语言完成的，竟然这么厉害，看来不得不学习一下了。"},{"title":"python高级用法","path":"/2025/03/11/python/","content":"python虽然简单，但用起来也是有很多的高级技巧的，那就让我缓慢的学习下吧。 异步代码示例123456789101112131415161718192021import asynciofrom time import sleep, perf_counterdef func1(): sleep(1) return &#x27;func1&#x27;def func2(): sleep(1) return &#x27;func2&#x27;def main(): print(func1()) print(func2()) if __name__ == &#x27;__main__&#x27;: start = perf_counter() main() end = perf_counter() print(f&#x27;Time taken: &#123;end-start&#125; seconds&#x27;) 1234567891011121314151617181920212223242526import asynciofrom time import sleep, perf_counterasync def func1(): await asyncio.sleep(1) return &#x27;func1&#x27;async def func2(): await asyncio.sleep(1) return &#x27;func2&#x27;async def main(): task1 = asyncio.create_task(func1()) task2 = asyncio.create_task(func2()) await task1 await task2 print(task1.result()) print(task2.result()) if __name__ == &#x27;__main__&#x27;: start = perf_counter() asyncio.run(main()) end = perf_counter() print(f&#x27;Time taken: &#123;end-start&#125; seconds&#x27;) 两段代码，第一段代码就是普通的串行逻辑，第二段代码使用了协程进行异步并发。两段代码的输出结果是： Time taken: 2.001054599881172 seconds Time taken: 1.0131963000167161 seconds 可以看到，异步并发有了明显的时长优势 运行过程分析事件循环调度： 事件循环先执行 task1 → 遇到 await asyncio.sleep(1)，挂起 task1，记录一个 1 秒的计时器回调。 事件循环立即切换到 task2 → 同样遇到 await asyncio.sleep(1)，挂起 task2，记录另一个 1 秒的计时器回调。 等待完成： 事件循环在 1 秒后收到两个计时器回调，恢复 task1 和 task2 继续执行。 最终通过 await task1 和 await task2 获取结果。 思考可以看到，两个 asyncio.sleep(1)，他们是由事件循环在单线程中交替调度，刚开始的确以为，这不就是同时运行吗，不就是变着花样的多线程吗。 但是这和多线程有一些本质区别，协程的切换不需要经历类似的上下文切换，只需要在用户态就可以完成。至于为啥，俺也还没搞懂，待过阵子补充。 python的引入python的引入实在是让人很头疼的一个地方，趁着机会，好好的梳理了一番 python文件，我们就喊它模块，可以有两种角色： 作为库&#x2F;包的一部分 作为单独的一个脚本 这样两种的角色下，他们引入的方式也不尽相同 以这样的文件结构举例： 123456789Package├── __init__.py├── ModuleA│ ├── __init__.py│ └── utils.py└── ModuleB ├── __init__.py ├── handlers.py &lt;- 在这里写了 from ..ModuleA.utils import xxxx └── handlers2.py &lt;- 在这里写了 from .handler import xxxx 首先是以单独的脚本运行handlers.py，那么你会收获这么一行报错： 1ImportError: attempted relative import with no known parent package 这是由于，当一个python以脚本角色运行时，它不属于任何的包，那就无法识别出相对的路径，无法使用相对引入。作为验证，可以打印__package__这个特殊变量，当作为脚本执行时，这个值是None，作为包的方式引入时，这个值是Package.ModuleB 有多种解决办法： 以模块的方式引入python -m Package.ModuleB.handlers，这样就可以找到对应的层级关系 使用绝对路径引入 设置环境变量，将项目根目录添加到模块搜索路径sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) 以单独脚本运行handler2.py时，会收获一行报错（前提是handler.py也可以直接用脚本方式执行）：SyntaxError: invalid syntax。 以脚本方式执行，引入同级的脚本只需要：from handler import xxxx 其次是以包的一部分运行， 以包形式运行的话，每一个python文件的导入都需要使用相对&#x2F;绝对路径，诸如from handler import xxxx这样的写法，会导致你的库导入时报错。 装饰器装饰器是python提供的一个语法糖，非常好用。其基本形式如下： 123456789101112def fuck(func): def warpper(): print(&#x27;before&#x27;) func() print(&#x27;after&#x27;) return warpper@fuckdef say_hello(): print(&#x27;hello&#x27;) say_hello() 函数输出为： 123beforehelloafter 其实这就等价于，只不过python提供了语法糖给你 1234def say_hello(): print(&#x27;hello&#x27;)fuck(say_hello)() 那么接下来要研究下，为什么fuck(say_hello)()会运行warpper里的内容。 很明显，fuck(say_hello)返回了一个函数对象，即内部定义的warpper。即等于warpper()，真还是挺巧妙的！ 那么还可以有一些更复杂些的情况： 1234567891011def decorator(func): def wrapper(*args, **kwargs): print(&quot;Decorating...&quot;) return func(*args, **kwargs) return wrapper@decoratordef greet(name): print(f&quot;Hello, &#123;name&#125;!&quot;)greet(&quot;Alice&quot;) 12345678910111213def repeat(n): def outer_wrapper(func): def inner_wrapper(*args, **kwargs): for _ in range(n): func(*args, **kwargs) return inner_wrapper return outer_wrapper@repeat(3)def say_hi(): print(&quot;Hi!&quot;)say_hi() 可以仔细对照上面的等价公式，看看实际展开后应该是什么样子的 这里还有个小问题，就是你执行了greet(&quot;Alice&quot;)，但其实执行的函数是wrapper，那也就丢失了greet的信息对吧。那怎么保留下来，让别人觉得你就是在执行greet函数呢 123456789101112131415from functools import wrapsdef logging_decorator(func): @wraps(func) &lt;- 注意这行代码 def wrapper(*args, **kwargs): print(f&quot;Calling &#123;func.__name__&#125;&quot;) return func(*args, **kwargs) return wrapper@logging_decoratordef calculate(): &quot;&quot;&quot;Perform a calculation.&quot;&quot;&quot; passprint(calculate.__name__) # 输出 &quot;calculate&quot;。 若不加则输出&quot;wrapper&quot; 下面有一个装饰器的妙用例子： 12345678910111213141516171819202122import timedef timeit(func): def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() print(f&quot;Execution time: &#123;end_time - start_time&#125; seconds&quot;) return result return wrapperdef fibonacci(n): if n &lt; 2: return n return fibonacci(n-1) + fibonacci(n-2)@timeitdef get_value(n): fibonacci(n)get_value(40) 通过装饰器，我们可以直接获取到执行一个斐波那契函数的用时，该代码输出：Execution time: 6.56 seconds 你以为这就完了么，不不不， 1234567891011121314151617181920212223import timefrom functools import cache &lt;-注意看这里def timeit(func): def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() print(f&quot;Execution time: &#123;(end_time - start_time):.2f&#125; seconds&quot;) return result return wrapper@cache &lt;-注意看这里def fibonacci(n): if n &lt; 2: return n return fibonacci(n-1) + fibonacci(n-2)@timeitdef get_value(n): fibonacci(n)get_value(40) 我们再加一个装饰器，缓存每次fibonacci计算得到的值，那漫长的递归树，就被狠狠的剪枝了，此时输出Execution time: 0.00 seconds 装饰器类前面使用从函数中返回函数的方式，定义了装饰器。不过好玩的是，我们仍有其他的实现方式，那就是一个实现了__call__函数的类 123456789101112131415161718192021222324def timeit(func): def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() print(f&quot;Execution time: &#123;(end_time - start_time):.2f&#125; seconds&quot;) return result return wrapperclass timecls: def __init__(self, func): self.func = func def __call__(self, *args, **kwds): start_time = time.time() result = self.func(*args, **kwds) end_time = time.time() print(f&quot;Execution time: &#123;(end_time - start_time):.2f&#125; seconds&quot;) return result@timeclsdef get_value(n): fibonacci(n) 这两种装饰器实现方式完全等价。按照前文的展开方式，对于装饰器类而言，展开后就是timecls(get_value)()。 具体分析，首先是timecls(get_value)调用了timecls的构造函数，将get_value作为了类的成员变量；然后obj()触发了类的__call__函数，这就类似C++的重载（）运算符，最后实现了计时的功能，帅。 上下文管理我们经常会遇到这样的代码： 12with open(&#x27;some_file&#x27;, &#x27;w&#x27;) as opened_file: opened_file.write(&#x27;Hola!&#x27;) 它等效于： 12345file = open(&#x27;some_file&#x27;, &#x27;w&#x27;)try: file.write(&#x27;Hola!&#x27;)finally: file.close() 可以看到，用with上下文管理语法，最大的好处就是，当离开with作用域后，它会自动为你释放资源 那实际上，它可以是基于定义了__enter__ __exit__ 方法的类实现的 12345678910111213class utils: def __init__(self, file_name, method): self.file = open(file_name, method) def __enter__(self): return self.file def __exit__(self, type, value, traceback): self.file.close() with utils(&quot;./hh.txt&quot;, &#x27;w&#x27;) as u: u.write(&#x27;fuck&#x27;) 那么分析下整体的工作流程： with utils(&quot;./hh.txt&quot;, &#39;w&#39;)首先调用了utils的构造函数，utils打开了获取了一个文件句柄 虽然调用__enter__，返回给了调用者，并as u拥有了一个别名 离开with作用域后，调用__exit__，销毁了文件资源 可以注意的是，__exit__有着额外的三个参数输入，这是被用于处理异常的。当我们什么都不管的时候，那异常会被with语句抛出。当然也可以选择在__exit__中处理，然后返回True，with外部则不会看到任何异常 其他实现上下文管理还有一种实现方式，是基于生成器的实现： 1234567from contextlib import contextmanager@contextmanagerdef open_file(name): f = open(name, &#x27;w&#x27;) yield f f.close() 这个有个重定向输出的实例： 123456from contextlib import redirect_stdoutimport syswith open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as f: with redirect_stdout(f): print(&#x27;This message will be written to output.txt&#x27;) yieldpdb调试这玩意和gdb差不多"},{"title":"C++多线程的学习","path":"/2025/03/11/thread/","content":"感觉多线程是很重要的一块内容，但是工作中却涉及的不多，故专门抽出一些时间进行学习 thread库基础用法12345678910void threadFunction() &#123; std::this_thread::sleep_for(std::chrono::seconds(1)); // simulate work std::cout &lt;&lt; &quot;Finished work in thread &quot;;&#125;int main() &#123; std::thread t(threadFunction); t.join(); return 0;&#125; 我们使用thread可以创建一个线程，它接受一个可调用的函数，以及变长参数 1234567template&lt;typename _Callable, typename... _Args, typename = _Require&lt;__not_same&lt;_Callable&gt;&gt;&gt; explicit thread(_Callable&amp;&amp; __f, _Args&amp;&amp;... __args) &#123; ··· &#125; 线程创建完成后，线程即刻启动~ 线程启动后，必须调用线程join 或者detach函数，指明是要等待线程完成还是分离线程。 等待线程很好理解，但是分离线程，让线程转入后台运行，那主线程先退出了怎么办？结论是，子线程被强制终止： 即使子线程尚未执行完任务，也会被立即终止。 子线程可能无法完成资源释放（如关闭文件、释放堆内存等），导致资源泄漏。 需要注意，若没有显示的写出来join或者detach，主线程退出后，不管子线程有没有执行完，都会直接报错 terminate called without an active exception 这是由于 主线程结束后，std::thread 对象 t 的析构函数被调用。 由于 t 仍是可联结的（joinable），触发 std::terminate()，程序立即终止。 todo:类内用thread 一些常会踩的坑简单提一嘴promise和future12345678910111213141516void get_int(std::promise&lt;int&gt; prom) &#123; std::this_thread::sleep_for(std::chrono::microseconds(500)); // return 42; prom.set_value(42);&#125;int main() &#123; std::promise&lt;int&gt; prom; std::future&lt;int&gt; fu = prom.get_future(); std::thread t(get_int, std::move(prom)); std::cout &lt;&lt; &quot;Waiting...&quot; &lt;&lt; std::endl; int res = fu.get(); std::cout &lt;&lt; &quot;Done! Result is &quot; &lt;&lt; res &lt;&lt; std::endl; t.join(); return 0;&#125; 锁123456789101112131415void add(int &amp;x) &#123; for (int i = 0; i &lt; 1e7; i++) &#123; x += 1; &#125;&#125;int main() &#123; int x = 0; std::thread t1(add, std::ref(x)); std::thread t2(add, std::ref(x)); t1.join(); t2.join(); std::cout &lt;&lt; x &lt;&lt; std::endl; return 0;&#125; 老生常谈的问题，不上锁的时候，这个结果不会是2*10e7，比如本地运行一次输出：10448963。根本原因在于： +&#x3D; 操作不是原子操作 解决方案一：加锁 12345678910111213141516171819std::mutex mt;void add(int &amp;x) &#123; for (int i = 0; i &lt; 1e7; i++) &#123; mt.lock(); x += 1; mt.unlock(); &#125;&#125;int main() &#123; int x = 0; std::thread t1(add, std::ref(x)); std::thread t2(add, std::ref(x)); t1.join(); t2.join(); std::cout &lt;&lt; x &lt;&lt; std::endl; return 0;&#125; TODO：解决方案二，原子变量？ 锁的再封装lock_guard123456void add(int &amp;x) &#123; for (int i = 0; i &lt; 1e7; i++) &#123; std::lock_guard&lt;std::mutex&gt; lg(mt); x += 1; &#125;&#125; 提供了一个lock_guard，其作用就是构造函数时上锁，离开作用域后析构函数开锁 unique_lockunique_lock是对lock_guard的进一步升级，主要增加的功能有： 支持手动开关锁 直接延迟加锁 这是个延迟加锁的示例 123456789101112131415161718192021std::timed_mutex mt;void add(int &amp;x) &#123; for (int i = 0; i &lt; 2; i++) &#123; std::unique_lock&lt;std::timed_mutex&gt; lg(mt, std::defer_lock); if (lg.try_lock_for(std::chrono::seconds(2))) &#123; x += 1; std::this_thread::sleep_for(std::chrono::seconds(2)); &#125; &#125;&#125;int main() &#123; int x = 0; std::thread t1(add, std::ref(x)); std::thread t2(add, std::ref(x)); t1.join(); t2.join(); std::cout &lt;&lt; x &lt;&lt; std::endl; return 0;&#125; 首先声明一个unique_lock，使用defer_lock模式延迟加锁。然后使用随后尝试加锁，等待2s，如果加锁不成功则直接退出。最终该程序输出值为：3 条件变量条件变量常常被用于生产者消费者模式，需要和unique_lock搭配使用 1234567891011121314151617181920212223242526272829303132333435363738std::mutex mtx;std::condition_variable cv;std::queue&lt;int&gt; que;void producer() &#123; for (int i = 0; i &lt; 20; i++) &#123; &#123; std::lock_guard&lt;std::mutex&gt; lg(mtx); que.push(i); std::cout &lt;&lt; &quot;Produced: &quot; &lt;&lt; i &lt;&lt; std::endl; cv.notify_one(); &#125; std::this_thread::sleep_for(std::chrono::milliseconds(100)); &#125;&#125;void consumer() &#123; while (true) &#123; std::unique_lock&lt;std::mutex&gt; lg(mtx); cv.wait(lg, []() &#123; return !que.empty(); &#125;); int item = que.front(); que.pop(); std::cout &lt;&lt; &quot;Consumed: &quot; &lt;&lt; item &lt;&lt; std::endl; if (item == 19) break; &#125;&#125;int main() &#123; std::thread t1(producer); std::thread t2(consumer); t1.join(); t2.join(); return 0;&#125; Consumer 线程 Producer 线程 1. 获取锁 2. 检查条件（如 data_ready == false） 3. 调用 cv.wait() → 释放锁 4. 获取锁 5. 修改 data_ready = true 6. 释放锁 7. 发送通知（cv.notify_one()） 8. 被唤醒，重新获取锁 9. 再次检查条件（data_ready == true） 10. 处理数据 11. 释放锁 注意和代码对照，生产者的普通的加锁，然后生产，然后释放，所以只使用lock_guard也就够了；但是消费者就不一样了，先用unique_lock上锁，然后cv会检查条件，如果不满足就要释放锁。因为需要手动的操作锁，所以cv只能接受unique_lock，而非lock_guard 线程池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class ThreadPool &#123;public: ThreadPool(int thread_num) : thread_num_(thread_num) &#123; for (int i = 0; i &lt; thread_num_; i++) &#123; threads_.emplace_back([this] &#123; this-&gt;worker(); &#125;); &#125; &#125; ~ThreadPool() &#123; &#123; std::unique_lock&lt;std::mutex&gt; lg(mtx_); stop_ = true; cv_.notify_all(); &#125; for (std::thread &amp;thread : threads_) &#123; if (thread.joinable()) &#123; thread.join(); &#125; &#125; &#125; void enqueue(std::function&lt;void()&gt; task) &#123; &#123; std::unique_lock&lt;std::mutex&gt; lg(mtx_); tasks_.push(task); &#125; cv_.notify_one(); &#125;private: std::vector&lt;std::thread&gt; threads_; int thread_num_; bool stop_; std::mutex mtx_; std::condition_variable cv_; std::queue&lt;std::function&lt;void()&gt;&gt; tasks_; void worker() &#123; while (true) &#123; std::unique_lock&lt;std::mutex&gt; lg(mtx_); cv_.wait(lg, [this]() &#123; return stop_ || !tasks_.empty(); &#125;); if (stop_ &amp;&amp; tasks_.empty()) &#123; return; &#125; std::function&lt;void()&gt; fuck = tasks_.front(); tasks_.pop(); fuck(); &#125; &#125;&#125;; todo:为什么好多地方都只能std::move"},{"title":"Git常用操作的查漏补缺","path":"/2025/03/10/git/","content":"Git也用了很久很久了，但是还是很多命令用的不熟悉，准备查漏补缺下。 分支切换git checkout切换到新分支： git checkout -b xxx切换到分支： git checkout xxx 不同的是，git checkout 还可以用于撤销文件的修改 git checkout -- &lt;file&gt;，可以撤销目前相对于暂存区的修改 这个–用于说明，后面跟着的不是commit id，而是文件名 如果要撤销暂存区的修改到工作区，就要写 git reset HEAD &lt;file&gt;。如果不加&lt;file&gt;就是暂存区的全部文件都撤销 git switchgit switch在后面的新版本提供了新的切换分支的命令，更加纯粹的命令切换到新分支： git switch -c xxx切换到分支： git switch xxx 不知道是啥git status显示目前工作区的一个状态，当你进行了修改，但没有add的时候 123456Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: README.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 当你进行了add的时候 123Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: README.md sparse-checkoutgit-lfs"},{"title":"C++疏漏记录","path":"/2024/12/27/cpp/","content":"作为靠C++吃饭的选手，但是好多地方都理解的不够到位，就在这个帖子里记录下每次学到的东西吧~ 最大堆&#x2F;优先队列C++提供了priority_queue，默认是最大堆 TODO依稀记得最大堆只需要使用数组就可以完成了，后面复习下数据结构！ 自定义排序priority_queue的默认排序规则是最大堆，当我们需要一个最小堆时，就需要一个自定义的排序对则，仿函数和lambda函数都可以完成这一人物。 1234567struct Compare &#123; bool operator()(int a, int b) &#123; return a &gt; b; &#125;&#125;;std::priority_queue&lt;int, std::vector&lt;int&gt;, Compare&gt; minHeap; 12345auto compare = [](int a, int b) &#123; return a &gt; b; &#125;;std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(compare)&gt; minHeap(compare); 但是其实一直不明白的是，为什么return a &gt; b就是从小按大排序呢。其实可以把C++的排序，按照优先级去理解。当compare(a,b) &#x3D; true时，那么a的优先级就是小于b的。 比如std::sort默认就是把优先级高的往后排，对于正常的int而言，且没有重载运算符，当 a &lt; b时，那么默认的int排序规则就会返回true，b的优先级就更高，那调用std::sort的时候，就会把b放在a后面，最后结果就是由小到大。 同理，priority_queue默认就是把优先级高的放在堆顶，我们重载的compare，当a的值小于b时，那么返回false，则会认为a的优先级比b高，那就会把a放在堆顶，因此就变成了最小堆。 对象构造之前堆std::sort做排序的时候，仿函数和lambda函数完全一致，但是突然发现，对于上面的优先队列而言，好像并不这么一回事。 12template &lt;typename T, typename Container = std::vector&lt;T&gt;, typename Compare = std::less&lt;typename Container::value_type&gt;&gt;class priority_queue; 这是优先队列的定义，注意这是一个模板，那注定，构造的时候，传入的模板的第三个参数，需要时一个类型，而非对象。 所以compare &#x3D; [](int a, int b) 定义了一个对象，但是传入模板的时候，需要decltype(compare)获取它的具体类型。而仿函数，本身就是一个struct，有明确的类型，直接可以作为模板参数。 此外，可以发现初始化时，lambda还需要多传一个lambda对象进去，而仿函数不用。这是因为priority_queue需要一个compare实例，仿函数有默认构造函数，可以直接构造；但lambda没有，所以就只能传一个进去。 左值右值左值右值在学习Modern C++必接触的概念，非常的重要。这里哥们先不写具体的概念，主要写下曾经遇到的一些疑惑的点 std::move这玩意到底是干啥的。。以前总是会觉得，顾名思义，肯定就是把一个右值移动给左值呀，这还用想。 但其实不然，std::move实际是用于类型转换，它的核心作用是将一个左值（或右值）强制转换为右值引用（T&amp;&amp;），然后由移动构造函数或者移动赋值函数进行资源的转移。它本身并不执行任何实际的“移动”操作，和move毛关系都没有。被骗了好久。fuck！ 下面是std::move的源码，可以看到的确仅仅只做了一个转换 1234template &lt;typename T&gt;constexpr std::remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp; t) noexcept &#123; return static_cast&lt;std::remove_reference_t&lt;T&gt;&amp;&amp;&gt;(t);&#125; 移动构造函数和移动赋值函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;algorithm&gt; // for std::swap#include &lt;iostream&gt;class DynamicArray &#123;public: // 默认构造函数 DynamicArray() noexcept : m_data(nullptr), m_size(0) &#123; &#125; // 构造函数：分配内存并初始化 explicit DynamicArray(size_t size) : m_size(size) &#123; m_data = (size &gt; 0) ? new int[size]() : nullptr; &#125; // 析构函数：释放内存 ~DynamicArray() &#123; delete[] m_data; &#125; // 拷贝构造函数（深拷贝） DynamicArray(const DynamicArray&amp; other) : m_size(other.m_size) &#123; if (other.m_data) &#123; m_data = new int[m_size]; std::copy(other.m_data, other.m_data + m_size, m_data); &#125; else &#123; m_data = nullptr; &#125; &#125; // 拷贝赋值运算符（深拷贝） DynamicArray&amp; operator=(const DynamicArray&amp; other) &#123; if (this != &amp;other) &#123; delete[] m_data; m_size = other.m_size; m_data = (other.m_data) ? new int[m_size] : nullptr; if (m_data) &#123; std::copy(other.m_data, other.m_data + m_size, m_data); &#125; &#125; return *this; &#125; // 移动构造函数（noexcept保证异常安全） DynamicArray(DynamicArray&amp;&amp; other) noexcept : m_data(other.m_data), m_size(other.m_size) &#123; other.m_data = nullptr; // 置空源对象指针 other.m_size = 0; // 置空源对象大小 other.flag = 1; // 标记源对象已被移动 &#125; // 移动赋值运算符（noexcept保证异常安全） DynamicArray&amp; operator=(DynamicArray&amp;&amp; other) noexcept &#123; if (this != &amp;other) &#123; // 处理自赋值 delete[] m_data; // 释放当前资源 m_data = other.m_data; m_size = other.m_size; other.m_data = nullptr; // 置空源对象指针 other.m_size = 0; // 置空源对象大小 other.flag = 1; // 标记源对象已被移动 &#125; return *this; &#125; // 其他成员函数（例如数据访问接口） int* data() const noexcept &#123; return m_data; &#125; size_t size() const noexcept &#123; return m_size; &#125; int get_flag() const noexcept &#123; return flag; &#125; // 获取标记private: int* m_data; size_t m_size; int flag = 0; // 1表示被移动&#125;; 有这么一些问题需要注意: 移动构造函数需要声明成noexcept，不然可能会影响到标准库的一些优化操作，例如vector在扩容时会优先使用移动操作（若移动构造函数标记为 noexcept），否则回退到拷贝操作。 移动赋值运算符必须检查 this !&#x3D; &amp;other，避免自移动导致资源丢失 确保移动后的源对象处于可安全析构状态（如 m_data &#x3D; nullptr）。 之前还会疑惑一个问题，被move的那个对象，最后变成了什么样子。其实完全取决你是怎么写的移动构造函数，你吧other变成什么样，它就是什么样。例如，上述代码中，我们将被移动的对象的flag置为了1，故下面的代码： 1234DynamicArray arr1(5);DynamicArray arr2 = std::move(arr1); std::cout &lt;&lt; arr1.get_flag() &lt;&lt; std::endl; // 输出1std::cout &lt;&lt; arr2.get_flag() &lt;&lt; std::endl; // 输出0 移动赋值运算符和拷贝赋值函数发现两种重载&#x3D;运算法的返回类型都是 T&amp;，猛然记得大学的时候好像还是知道的，现在想不起来，重新梳理下： 是需要支持链式赋值，如：12MyClass a, b, c;a = b = c; // 等价于 a = (b = c) 与内置类型的行为一致，C++ 的内置类型（如 int、double 等）的赋值操作返回的是 左值引用：12int x, y, z;(x = y) = z; // 合法：先执行 x = y，再执行 x = z 若返回T，而非T&amp;，返回时触发拷贝构造函数1234MyClass operator=(const MyClass&amp; other) &#123; // 赋值逻辑... return *this; // 返回时触发拷贝构造函数&#125; 允许对赋值结果进行其他操作12MyClass obj;(obj = getValue()).doSomething(); // 对赋值后的对象调用方法 一个注意点123456789101112class Widget &#123; std::vector&lt;int&gt; data_&#123;&#125;;public: void set_data(std::vector&lt;int&gt;&amp; data) &#123; data_ = data; // 这里会发生数据拷贝 &#125; void set_data(std::vector&lt;int&gt;&amp;&amp; data) &#123; data_ = std::move(data); // 这里会发生数据移动 &#125;&#125;; 这里会有一些疑惑，为什么第二个set_data，函数参数已经是接收一个右值了，但是为什么仍然需要std::move将其转成右值嘞。 主要原因： 这么写只是声明了，函数只能接受一个右值作为参数 但尽管参数类型是右值引用（&amp;&amp;），但 参数本身是一个具名变量。在 C++ 中，所有具名变量都是 左值，无论其类型如何，所以data在函数内部是一个左值 若要在函数内部继续触发移动语义，必须用 std::move 将 data 转为右值。 如果右值引用参数在函数内部自动被视为右值，可能导致下面问题：123void func(std::vector&lt;int&gt;&amp;&amp; data) &#123; use_data(data); // 如果 data 自动变成右值，此处可能意外移动 data！&#125; atomicstd::sort实现选择排序选择排序的实现思路是：从第一个未排序的位置向后寻找最小值的位置，然后和当前第一个未排序的元素交换位置。 选择排序有个比较明显的问题，就是排序的稳定性。比如目前有一个序列：2&#39; 2&#39;&#39; 2&#39;&#39;&#39; 1&#39;，那选择排序完成一次交换后，序列变为1&#39; 2&#39;&#39; 2&#39;&#39;&#39; 2&#39;， 可见，2元素之间的排布顺序发生了改变，这就是选择排序的不稳定性。 时空复杂度：$O(N^2)$， 具体操作次数 $\\frac{n^2}{2}$ 无论原数组是否有序，不影响选择排序执行的次数 为了保证选择排序的稳定性，可以将交换操作，转换为了依次的向右平移【第一个未排序元素，最小元素的前一个元素】，随后在空出的位置插入。这一操作显然增加了排序的操作次数，时间复杂度仍是$O(N^2)$ 冒泡排序冒泡排序的实现是：把nums[sortedIndex:]的元素，从后向前遍历，如果当前元素比前一个元素小，则进行交换，如此反复。相当于每一轮遍历，都会把未排序的最小的元素挪到最前面 const的作用妈的，const放在不同的位置有着不同的含义，总是会忘记，今天狠狠的总结下： 修饰普通变量12const int a = 10; // a 是常量，不可修改a = 20; // 错误：编译时报错 修饰指针123const int* p = &amp;a; // 或 int const* p = &amp;a;*p = 20; // 错误：不能修改指向的值p = &amp;b; // 合法：可以改变指针指向 123int* const p = &amp;a;*p = 20; // 合法：可以修改指向的值p = &amp;b; // 错误：不能修改指针指向 123const int* const p = &amp;a;*p = 20; // 错误：不能修改指向的值p = &amp;b; // 错误：不能修改指针指向 记忆这一点只需要记住固定的规则： const 修饰的是左侧的内容（如果左侧没有内容，则修饰右侧）： T 和 * 要单独拆开看 左定值：const 在 * 左边时，修饰值。 右定针：const 在 * 右边时，修饰指针。 修饰引用1234int x = 10;const int&amp; ref = x; ref = 20; // 错误：不能通过 ref 修改 xx = 20; // 合法：直接修改 x 是允许的 但是没有int&amp; const这样的语法，因为引用一旦初始化后，就永久绑定到某个对象，不能再指向其他对象 修饰函数参数const 修饰形参时，函数内部不能修改该参数： 123void func(const int value) &#123; value = 10; // 错误：value 是常量&#125; 防止函数内部修改指针&#x2F;引用指向的值： 1234567void func(const int* ptr) &#123; // 防止修改 ptr 指向的值 *ptr = 10; // 错误&#125;void func(const std::string&amp; str) &#123; // 防止修改原字符串 str = &quot;new&quot;; // 错误&#125; 修饰成员函数123456789class MyClass &#123;public: int getValue() const &#123; // 常量成员函数 // data = 10; // 错误：不能修改成员变量 return data; &#125;private: int data;&#125;; 修饰函数返回值返回一个不可修改的值或指针&#x2F;引用： 1234567891011121314const int func() &#123; return 42; &#125;const int* getPointer() &#123; static int x = 10; return &amp;x; &#125;// 使用int a = func(); // 合法：拷贝返回值func() = 20; // 错误：返回的是常量const int* p = getPointer();*p = 20; // 错误：不能修改 修饰类对象对象被声明为 const，只能调用其 const 成员函数： 123const MyClass obj;obj.getValue(); // 合法：调用 const 成员函数obj.modifyData(); // 错误：非 const 成员函数 修饰类成员变量成员变量必须在构造函数初始化列表中初始化，且不可修改： 123456class MyClass &#123;public: MyClass(int val) : constData(val) &#123;&#125; // 必须初始化private: const int constData; // 常量成员变量&#125;;"},{"title":"My Trick on Windows & Linux","path":"/2024/12/23/trick/","content":"这里记录一下自己在鼓捣自己电脑的时候，成功试验并觉得有效提升使用体验的一些小技巧吧~ Windows终端windows的cmd命令，可以说是非常的让人无语了，和linux完全的不兼容。而且学习成本非常的高昂。太扯淡啦！&#x1F4A9; 后面推出的WT（windows terminal），虽然在原cmd的基础上增添了很多东西，但是还是完全没法用的程度。继续无语&#x3D;&#x3D;&#x3D; &#x1F33F;。 幸好我们拥有git！安装完git后，我们会直接得到一个git bash。提供了非常接近bash的环境！狂喜！那么，我们可以直接在WT中，设置默认打开的终端环境，这样体验感直接up up! &#x1F44F; 同理，vscode中也可以如此设置~ 快捷键WT的使用频率一高，不想在桌面增加快捷方式，又想要一个快捷的打开方式，该怎么办呢？很自然的想法就是，设置一个快捷键，类似ubuntu的 ctrl + shift + T 一键打开终端。 个人了解的windows的快捷键添加方式有两种： exe发送快捷方式到桌面，右键，巴拉巴拉找到一个快捷键（记不清了） autohotkey！新发现的很不错的软件，本人现在的快捷键也是通过此来配置的 autohotkey官网可直接安装，仅需3M。接下来就是简单了解下它的脚本规则，快捷键的设置规则就是： 1234hotkey ::&#123; Run app&#125; 当然这个软件应当是还可以做很多事情，但是哥们只看了几秒快捷键的设置，只知道这些。 本人目前设置了两个快捷键，已爽翻： Ctrl + Shift + W -&gt; WT Ctrl + Shift + T -&gt; WSL 最后一步将配置文件放置到C:\\Users\\{user_name}\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup中，即可开机自启，大功告成！ gcc &amp; clang 安装1pacman -Q 查看安装了哪些包 1pacman -S &#123;package name&#125; 安装指定的包 1pacman -Ss 列出所有可用的包（包括未安装的） 1pacman -Qi &#123;package_name&#125; 查看某个包的详细信息 1pacman -Syu 更新包管理器 本人用mysy2构建了全套的C++编译工具，包括clang、clangd、gcc、make、cmake。爽歪歪。本条命令用来安装clangd 1pacman -S mingw-w64-ucrt-x86_64-clang-tools-extra 搭配clang插件，vscode写C++的体验感再一次提升了。clion请直接退休好吗。值得一提的，哥们曾在wsl也搞过clangd，但是启动后的几秒就会直接崩掉，且没有找到解决办法。也许是分配给wsl的内存太少了？不过现在在windows下的体验还是非常的顶呱呱的。嘻。"},{"title":"LeetCode刷题记录","path":"/2024/12/21/leetcode/","content":"记录刷题的每一天！感受逐渐变强的自己！ 环境配置VsCode + labuladong vscodevscode的安装无需多言了 leetcode 插件在leetcode网站上刷题体验感实际上是很一般的。主要是补全差劲；字体难看；等等等。所有就有了leetcode刷题插件的诞生。可以自由的在vscode里读题、写代码、提交代码。 但很不好的是，它给你生成的代码内容是不包含头文件的，会导致vscode报错飘红，体验感依旧不足够高。 labuladong的算法插件labuladong大佬在leetcode插件上进一步开发的。属于是弥补了原插件的许多不足之处。具体的说法和细则，请看官网。体验感已经是本人能找到的非常棒的了。不过还有缺点就是，不能直接构造main函数，构建测试用例，使得可以直接开始debug。 另外仍需注意，该插件只能用cookie登录。需要在网络控制台中，抓一个带有cookie字样的包然后右键， Copy as cURL (bash)，随后开启新世界大门！ 547 省份数量老听并查集的大名，但是一直没有学习过，直接拿上547题来练手。 并查集学过一遍之后，并查集应该是要用数组表示的树？很吊的。 反正啥操作前都加个find_parent就对了！ 构造函数一个并查集可以有n个节点，初始化时，各个节点都先自己指向自己，每个节点都是一个单独的集合。 123456UnionFind(int n)&#123; array_.resize(n); for(int i = 0 ; i &lt; n;i++)&#123; array_[i] = i; // 并查集自己先指向自己 &#125;&#125; 合并函数合并函数就是一个集合的父节点，指向另一个集合的父节点，这样他们就合并成了一撮，变成了同一个集合。 1234void to_union(int child, int parent)&#123; // ! 注意，并查集的操作，是对父节点的操作，一切要以父节点为准 array_[find_parent(child)] = find_parent(parent);&#125; 其他的合并方式假如union(1,2)、union(2,3)、union(3,4)，这样循环的调用，那节点之间的指向关系，明显是一个链状的，当然这是最坏的情况，有没有什么好的压缩的方法呢？ 其实就是希望合并之后，树的高度尽可能的矮嘛，那可以额外的增加一个数组，记录每个集合的高度，合并的时候，矮的指向高的，不就不会导致高度过分的增加了嘛。 当然，更佳的一个做法是，用上路径压缩。 寻根函数（带路径压缩）讲解视频 12345678910int find_parent(int i)&#123; // 视频中所述，并查集要注意 !路径压缩! 不然一个集合里的排布是一长串，复杂度不是最优 if (array_[i] == i)&#123; return i; // 已经找到根节点了 &#125;else&#123; array_[i] = find_parent(array_[i]); // 这里就是在做路径压缩 return array_[i]; &#125;&#125; 一共有多少集合呢反正我是用一个集合，但是感觉实际是很愚蠢的！ 1234567int get_num()&#123; unordered_set&lt;int&gt; statistic_set; for (int i = 0; i &lt; array_.size(); i++)&#123; statistic_set.insert(find_parent(i)); &#125; return statistic_set.size();&#125; 可以在每次合并，就将合并次数++！那集合的数量，不就是 size - merge_count吗！ 不解但是并查集的时间复杂度咋算呢？回头再学习学习吧。 链表题目21.合并两个有序链表 &amp;&amp; 86.分隔链表主要涉及到的技巧是： dummy虚拟头结点的使用，可以有效的避免很多的边界条件判断 如果是把原链表重新构造成一个新的链表，那总是需要断开原链表之间的连接关系，欲断不断，就会导致最后的链有可能成环，一定要注意！ 23.合并k个有序链表这题一看有点蒙蔽，这怎么比节点们的大小，然后瞅一眼题解，竟然是已经遗忘已久的优先队列，惭愧惭愧，彻底的还给老师了。这题显然也是没有涉及new操作的，把原链表拼成新链表的操作，类似上面提到的，要断开每个节点之间的联系。当然这题可以不断，但是还是保持这个好习惯的好。 然后值得记录的是，C++优先队列的初始化，记录在同级的C++博客中了。 19.删除链表的倒数第N个节点主要是设计到了寻找倒数第N个节点的技巧，使用快慢指针。就是一个指针先走N步，然后另一个指针再开始走，当快指针走到头的时候，慢指针就走到了倒数第N个节点。 12345678910111213141516// 返回链表的倒数第 k 个节点ListNode* findFromEnd(ListNode* head, int k) &#123; ListNode* p_fast = head; // p_fast 先走 k 步 for (int i = 0; i &lt; k; i++) &#123; p_fast = p_fast -&gt; next; &#125; ListNode* p_slow = head; // p_fast 和 p_slow 同时走 n - k 步 while (p_fast != nullptr) &#123; p_slow = p_slow -&gt; next; p_fast = p_fast -&gt; next; &#125; // p_slow 现在指向第 n - k + 1 个节点，即倒数第 k 个节点 return p_slow;&#125; 注意的是，当p_fast指向链表的尾部的nullptr时，p_slow指向的才是倒数第k个节点。当p_fast指向链表的最后一个节点时，p_slow指向的是倒数第k+1个节点。 比较极限的情况是，链表要删除第一个节点，但这时候第一个节点前面也没有节点了，此时就需要dummy节点了，在链表最开始插上一个头结点，这样就可以避免很多的边界条件判断。当你使用了dummy节点后，返回值一般是dummy-&gt;next，本题可不能看到说返回头节点，就return head，会出错。 876.链表的中间结点这题思路倒是很简单，一快一慢就好。主要是停止的边界条件怎么设置。 12345678910ListNode* middleNode(ListNode* head) &#123; ListNode *p_slow = head, *p_fast = head; // !仔细思考下这个边界条件的设置 // while (p_fast-&gt;next != nullptr and p_fast != nullptr) &#123; while (p_fast != nullptr and p_fast-&gt;next != nullptr) &#123; p_slow = p_slow-&gt;next; p_fast = p_fast-&gt;next-&gt;next; &#125; return p_slow; &#125; 快指针每次移动两步，那什么是否停止移动呢？就是当快指针不能再往下移动了，即快指针不为空，或者快指针的下个元素不空。 需要注意一点，p_fast != nullptr 要放在前面先判断，否则p_fast == nullptr时，执行p_fast-&gt;next != nullptr铁会出现问题。 142.环形链表链表如果有环，典型做法就是，快慢指针，如果相遇了就证明有环。 1234567while (p_fast != nullptr and p_fast-&gt;next != nullptr) &#123; p_slow = p_slow-&gt;next; p_fast = p_fast-&gt;next-&gt;next; if (p_slow == p_fast) &#123; break; &#125;&#125; 就两种情况退出循环: 无环，fast走到尽头，触发while条件，退出 有环，相交退出 可以发现，即使长度为1的有环无环链表，这个代码都能正常工作，所以其实无需什么边界情况处理。对于此题，要找到入口处的节点，需要一些数学证明： 我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步 fast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。 这里是整数倍哦。 假设相遇点距环的起点的距离为 m，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。 巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点 沿用此思路，即可解出此题 160.相交链表本人的直接想法就是，先遍历一遍，找到他们的头距离差距，然后直接对齐，顺序往后移动就好~ 123456789101112131415161718192021222324252627282930ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; int len_a = 0, len_b = 0; ListNode *pa = headA, *pb = headB; while (pa != nullptr) &#123; pa = pa-&gt;next; len_a++; &#125; while (pb != nullptr) &#123; pb = pb-&gt;next; len_b++; &#125; pa = headA, pb = headB; if (len_a &gt; len_b) &#123; int delta_len = len_a - len_b; for (int i = 0; i &lt; delta_len; i++) &#123; pa = pa-&gt;next; &#125; &#125; else &#123; int delta_len = len_b - len_a; for (int i = 0; i &lt; delta_len; i++) &#123; pb = pb-&gt;next; &#125; &#125; while (pa != pb) &#123; pa = pa-&gt;next; pb = pb-&gt;next; &#125; return pa;&#125; labuladong提供了两个更奇思妙想的方法： 第一条遍历完去走第二条，第而条遍历完去走第一条，当他们相遇的时候，就成了 公链的最后一个节点指向其中一条的起点，问题就变成了，寻找环的起点，即142题 数组题目26.删除有序数组中的重复项这题一开始的想法是，一个指针指向前面，一个指针指向后面，然后遇到重复的就swap一下，但是这样搞完之后就不有序了，想了半天没有想到解决办法。可恶啊，被一道easy题给拿下了。 思路同样是快慢指针，但是这个不同于链表快慢指针是慢指针的两倍速，但是本题，slow是待在后方，维护着迄今为止的正确的结果，fast是在前面探路的，他们的速度差距是由数组元素的排布造成的。 本人的笨笨代码，实在是太蠢了。 index不用非要从1开始 也不用记录fast走过的上一个值，只需要比较fast和slow的值，因为slow的元素必定是最新的不重复的那个值 12345678910111213141516int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int slow = 1, fast = 1; int size = nums.size(); int last_value = nums[0]; while(fast &lt; size)&#123; if(nums[fast] == last_value)&#123; fast++; &#125;else &#123; nums[slow] = nums[fast]; last_value = nums[fast]; fast++; slow++; &#125; &#125; return slow;&#125; 标准答案 12345678910111213141516int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) &#123; return 0; &#125; int slow = 0, fast = 0; while (fast &lt; nums.size()) &#123; if (nums[fast] != nums[slow]) &#123; slow++; // 维护 nums[0..slow] 无重复 nums[slow] = nums[fast]; &#125; fast++; &#125; // 数组长度为索引 + 1 return slow + 1;&#125; 27.移除数组和本题同理 283.移动零我简直是个智障吧，这也没想出来。其实只需要两步： 按照27题的思路，删除所有为0的元素 把末尾的元素，全部置为0 比较有迷惑性的是这道题的表述，他说把为0的元素移动到最后。这个移动就很灵性，让我以为必须是什么元素要交换一下，所以该怎么遍历，才能把0都给换到后面呢。所以苦思冥想了半天，还是太死板了…… 但是答案就是先删再赋值。虽然简单，但实在是巧妙呀。 数组题目，凡是涉及到原地修改、保持原来元素的相对顺序 等要求，就往快慢指针这里想一想。 左右指针基本上有两种形式： 左右指针向中间收缩 左右指针向两边扩散 167.两数之和这道题就是典型的向中间收缩的左右指针。思路并不困难，但是有继续引申的nSum问题，后面得好好继续研究下。 1234567891011121314vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int left = 0, right = numbers.size() - 1; while (left &lt; right) &#123; int sum = numbers[left] + numbers[right]; if (sum &lt; target) &#123; left++; &#125; else if (sum &gt; target) &#123; right--; &#125; else if (sum == target) &#123; return &#123;left + 1, right + 1&#125;; &#125; &#125; return &#123;0, 0&#125;;&#125; 5.最长回文子串这道题是典型的向两边扩散的左右指针，一开始确实也没啥思路，看了答案才豁然开朗。 回文串分为奇数和偶数，奇数时有一个中心点，偶数时有两个中心点。首先给出一个有中心点向两边扩散，寻找最长回文串的代码。 12345678string huiwenStr(string&amp; str, int left, int right) &#123; while (left &gt;= 0 and right &lt; str.size() and str[left] == str[right]) &#123; left--; right++; &#125; // !notice 注意当它停止的时候，left指向了回文串的两边，所以要left + 1 return str.substr(left + 1, right - left - 1);&#125; 代码固定需要传入两个中心点，left = right 就是奇数串，left + 1 = right 就是偶数串。然后需要注意边界控制，left、right应该是一个正确的索引，不能越界，所以是left &gt;= 0 and right &lt; str.size()，之前自己写成left &gt; 0显然是有问题的 然后需要注意，while循环需要保证回文串的特性才能继续循环，即tr[left] == str[right]，以及最后返回的子串，left + 1才是回文串的起点，长度为right - left - 1 最后仅需要遍历每一个可能的中心点，就可以找到最长的回文串 123456789101112131415string longestPalindrome(string s) &#123; string max_str = &quot;&quot;; for (int i = 0; i &lt; s.size(); i++) &#123; // 以i为中心的奇数串 string str1 = huiwenStr(s, i, i); string str2 = huiwenStr(s, i, i + 1); if (str1.size() &gt; max_str.size()) &#123; max_str = str1; &#125; if (str2.size() &gt; max_str.size()) &#123; max_str = str2; &#125; &#125; return max_str;&#125; 二分查找今天，我要学会自己做二分搜索！ 首先，我们要明确，二分搜索的区间可以分为左闭右闭[left, right],也可以分为左闭右开[left, right)，但是哥们独爱左闭右闭，所以后续所有的写法都是左闭右闭。 普通二分搜索1234567891011121314int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; // target比中间值大，那么就要从右边的区间找 left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return -1;&#125; 左闭右闭体现在初始化的时候，如果right = nums.size()-1，那么nums[right]就是可以直接访问的，那么右边区间就是闭合的，就是左闭右闭。 while循环何时停止呢？当然是[left, right]这个区间不成立的时候，即left = right + 1当nums[mid] 不符合target时，那就要调整区间的范围了。调整的幅度就是在mid左右，设置为新的左&#x2F;右边界 左&#x2F;右边界的二分搜索 &amp; 34.在排序数组中查找元素的第一个和最后一个位置之前都没有想过，二分搜索竟然还能这么玩。 123456789101112131415161718192021int left_bound(vector&lt;int&gt;&amp; nums, int target) &#123; // 可以自动适配size = 0 的情况，无需额外适配 int res1; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; right = mid - 1; &#125; else if (nums[mid] &gt;= target) &#123; right = mid - 1; &#125; else if (nums[mid] &lt;= target) &#123; left = mid + 1; &#125; &#125; if (left &gt;= nums.size()) &#123; res1 = -1; &#125; else &#123; res1 = nums[left] == target ? left : -1; &#125; return res1;&#125; 此二分搜索大部分和普通的是一样的，但是当nums[mid] == target时，就有区别了。因为我们要找左边的边界，那么就更新区间右边界，继续去找。 本部分我一开始的疑问是，如果此时的mid已经是最左边的target元素，那就调用了right &#x3D; mid - 1，去再左边找元素了，那岂不是就再也找不到这个target元素了吗？ debug了一遍才发现，如果此时的mid已经是最左边的target元素，那么继续找下去，left和right一定会走到：left = right = mid - 1！然后，进入分支left = (left + right) / 2 + 1 = mid -1 + 1 = mid，可以发现，当退出while后，left恰巧又指向了最左边的target元素，很巧妙，很神奇吧。太屌了。 还有个区别是，当数组中不存在target元素时，需要额外的边界控制： target大于数组的最大值，很明显，这种情况，left最后会指向 nums.size()，发生了越界，所以需要特判，越界了返回-1 target的大小是包含在数组的上下界里的，这种情况，left会指向大于 target 的最小索引，所以需要判断nums[left] == target，不等于则是没有找到 1234567891011121314151617181920int right_bound(vector&lt;int&gt;&amp; nums, int target) &#123; int res2; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt;= target) &#123; right = mid - 1; &#125; else if (nums[mid] &lt;= target) &#123; left = mid + 1; &#125; &#125; if (right &lt; 0) &#123; res2 = -1; &#125; else &#123; res2 = nums[right] == target ? right : -1; &#125; return res2;&#125; 寻找右边界一样的道理，只不过 nums[mid] == target时，就更新区间左边界，继续去找。 right有可能指向-1，数组越界，需额外判断 滑动窗口也是左右指针，但和数组一节里的左右指针完全不一样，这个左右像是分先后平移的窗户，并不会扩散或者收缩。 滑动窗口的时间复杂度是O(N)，它和双重循环暴力遍历的区别是：无需要穷举所有子串，通过对穷举过程进行剪枝优化，避免冗余计算 通用模板是： 1234567891011121314151617181920212223242526272829303132333435void slidingWindow(string s) &#123; // 用合适的数据结构记录窗口中的数据，根据具体场景变通 // 比如说，我想记录窗口中元素出现的次数，就用 map // 如果我想记录窗口中的元素和，就可以只用一个 int auto window = ... int left = 0, right = 0; while (right &lt; s.size()) &#123; // c 是将移入窗口的字符 char c = s[right]; window.add(c); // 增大窗口 right++; // 进行窗口内数据的一系列更新 ... // *** debug 输出的位置 *** printf(&quot;window: [%d, %d) &quot;, left, right); // 注意在最终的解法代码中不要 print // 因为 IO 操作很耗时，可能导致超时 // 判断左侧窗口是否要收缩 while (window needs shrink) &#123; // d 是将移出窗口的字符 char d = s[left]; window.remove(d); // 缩小窗口 left++; // 进行窗口内数据的一系列更新 ... &#125; &#125;&#125; 注意right++的位置，放在外层while循环开头、末尾都是可以的，一个是左闭右开区间，一个是左闭右闭区间，基本没啥区别。 76.最小覆盖子串这道题思路是： 右边界不断向右扩散 当右边界扩散到可以满足要求的时候，收缩左边界 收缩左边界途中，记录更新最小的子串 收缩到不再满足条件，继续扩散右边界，重复这个步骤 1234567891011121314151617181920212223242526272829303132333435363738string minWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; map_count; vector&lt;char&gt; total_char; for (int i = 0; i &lt; t.size(); i++) &#123; map_count[t[i]]++; &#125; for (auto&amp; pair : map_count) &#123; total_char.push_back(pair.first); &#125; auto check_func = [&amp;]() -&gt; bool &#123; for (auto c : total_char) &#123; if (map_count[c] &gt; 0) &#123; return false; &#125; &#125; return true; &#125;; int left = 0, right = 0; int min_len = INT_MAX; int start = 0; while (right &lt; s.size()) &#123; if (map_count.find(s[right]) != map_count.end()) &#123; map_count[s[right]]--; &#125; while (check_func()) &#123; if (right - left + 1 &lt; min_len) &#123; min_len = right - left + 1; start = left; &#125; if (map_count.find(s[left]) != map_count.end()) &#123; map_count[s[left]]++; &#125; left++; &#125; right++; &#125; return min_len != INT_MAX ? s.substr(start, min_len) : &quot;&quot;;&#125; 这题我写的时候踩过两个坑： 如果你把right++ 写到了外层循环的一开始，那min_len的计算就是right - left，这里就是左闭右开，一个是左闭右闭的区别 我以为，如果找到了串，那while循环结束后，最后left和right就是最小的串了。但并不是这样！实际上窗口是在不断地扩散、收缩、扩散….子串可能在其中的一次收缩中出现，所以要用变量去记录，而非最后的left、right就是正确结果 关于本题怎么记录是否可以收缩了，我直接就是遍历哈希表，进行查找，还有一种题解可以看下题的写法 567.字符串的排列这道题和上一道题非常非常的类似，只不过这道题的窗口长度是固定的，解法如下： 1234567891011121314151617181920212223242526272829303132bool checkInclusion(string s1, string s2) &#123; unordered_map&lt;char, int&gt; little_map, big_map; for (auto c : s1) &#123; little_map[c]++; &#125; int left = 0, right = 0; int valid = 0; while (right &lt; s2.size()) &#123; if (little_map.find(s2[right]) != little_map.end()) &#123; big_map[s2[right]]++; if (big_map[s2[right]] == little_map[s2[right]]) &#123; valid++; &#125; &#125; while (right - left + 1 &gt;= s1.size()) &#123; if (valid == little_map.size()) &#123; return true; &#125; if (little_map.find(s2[left]) != little_map.end()) &#123; if (big_map[s2[left]] == little_map[s2[left]]) &#123; valid--; &#125; big_map[s2[left]]--; &#125; left++; &#125; right++; &#125; return false;&#125; 这种题解记录收缩条件，用的是一个vaild计数，vaild代表符合条件的字符的数量。 本题需要注意： valid == little_map.size(), 等于的是s1中出现的字符类型数量，而不是s1的长度 while中的条件，要有等号&#x3D;。可以想象，当窗口长度正好为s1长度时，while里left–，紧接着while退出之后，right++，正好可以维持窗口长度不变 本题窗口长度是固定的，所以第二层的while可以是if big_map[s2[right]]++ big_map[s2[left]]--的时机不同，一个是在big_map操作前，一个是在big_map操作后 438.找到字符串中所有字母异位词 与本题同理 3.无重复字符的最长子串这题的收缩左边界的条件比较独特，是s[right]的计数有多个 123456789101112131415int lengthOfLongestSubstring(string s) &#123; int left = 0, right = 0; int max_len = 0; unordered_map&lt;char, int&gt; alpha_count; while (right &lt; s.size()) &#123; alpha_count[s[right]]++; while (alpha_count[s[right]] &gt; 1) &#123; alpha_count[s[left]]--; left++; &#125; max_len = max(max_len, right - left + 1); right++; &#125; return max_len;&#125; 动态规划作为一直刷题都没刷明白的一大块，这一次，我要狠狠的拿下它！ 动态规划的三要素： 重叠子问题 最优子结构 状态转移方程 所谓动态规划，就是从底到高的迭代，为啥这么难想呢，我觉得很大一部分原因是因为逆着人的思维模式了。能从底到高，就能从高到低，这就是我们常说的，递归！ 斐波那契数列典型的斐波那契数列，可以很好的诠释动态规划的精髓。首先，一开始学会的解决就是递归，如下如所示： 很明显，这样的递归树，有很多的节点相当于被重复计算了，时间复杂度 $O(2^n)$，直接爆炸。显然我们可以用一个数组记录每个节点的值，当递归的时候发现数组里有值，那么就直接返回，无需重新计算，即一个备忘录。如下图所示，可以发现，就像是对这颗递归树进行了剪枝。 再精简下，就是：可见已经被优化成了一个链表形式，时间复杂度$O(n)$ 这种解法是「自顶向下」进行「递归」求解，动态规划则是「自底向上」进行「递推」求解，可有代码： 123456789101112int fib(int N) &#123; if (N == 0) return 0; vector&lt;int&gt; dp(N + 1); // base case dp[0] = 0; dp[1] = 1; // 状态转移 for (int i = 2; i &lt;= N; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[N];&#125; 322.零钱兑换首先，如果你需要money，此时硬币的选项有coin，那需要多少个硬币呢，显然就是 dp[money - coin] + 1。那这样就拆解成了子问题。我们以递归的方式去思考，那money -coin继续向下分解子问题，啥时候会返回呢。那就是有确切解的时候了。当money &#x3D; 0时，需要0个；当money &lt; 0时，无解 这样我们就可以写出一个递归形式的代码了： 123456789101112131415161718192021222324252627class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; // 题目要求的最终结果是 dp(amount) return dp(coins, amount); &#125;private: // 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币 int dp(vector&lt;int&gt;&amp; coins, int amount) &#123; // base case if (amount == 0) return 0; if (amount &lt; 0) return -1; int res = INT_MAX; for (int coin : coins) &#123; // 计算子问题的结果 int subProblem = dp(coins, amount - coin); // 子问题无解则跳过 if (subProblem == -1) continue; // 在子问题中选择最优解，然后加一 res = min(res, subProblem + 1); &#125; return res == INT_MAX ? -1 : res; &#125;&#125;; 当然了，这样可能会有很多的子问题被重复计算，那么只需要用一个备忘录进行记录，不就好啦。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; memo = vector&lt;int&gt; (amount + 1, -666); // 备忘录初始化为一个不会被取到的特殊值，代表还未被计算 return dp(coins, amount); &#125;private: vector&lt;int&gt; memo; int dp(vector&lt;int&gt;&amp; coins, int amount) &#123; if (amount == 0) return 0; if (amount &lt; 0) return -1; // 查备忘录，防止重复计算 if (memo[amount] != -666) return memo[amount]; int res = INT_MAX; for (int coin : coins) &#123; // 计算子问题的结果 int subProblem = dp(coins, amount - coin); // 子问题无解则跳过 if (subProblem == -1) continue; // 在子问题中选择最优解，然后加一 res = min(res, subProblem + 1); &#125; // 把计算结果存入备忘录 memo[amount] = (res == INT_MAX) ? -1 : res; return memo[amount]; &#125;&#125;; 这样就是一个自顶向下的递归过程了，那这个思路已经想明白，那我们直接就进行一个自底向上的改造。 123456789101112int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int money = 1; money &lt;= amount; money++) &#123; for (auto coin : coins) &#123; if (money - coin &gt;= 0 and dp[money - coin] != INT_MAX) &#123; dp[money] = min(dp[money], dp[money - coin] + 1); &#125; &#125; &#125; return dp[amount] == INT_MAX ? -1 : dp[amount];&#125; 这就是完整的一次动态规划的做题经历 300.最长递增子序列其实感觉动态规划还真的有点难想的。这道题实现都已经知道是解法类型了，但还是没想出来。没想出来的一大原因是：总觉得动态规划时间复杂度邦邦低，一个for循环就解决了，所以按着这个思路想，还真是想不出来。 这道题，dp[i]的含义是：以i元素结尾的子序列，最长的长度。直接可得代码： 1234567891011int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; dp(nums.size(), 1); for (int i = 1; i &lt; nums.size(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; &#125; return *max_element(dp.begin(), dp.end());&#125; 这道题还有一个二分搜索的方法，时间复杂度是 $O(logN)$，题解也非常多，仅列出代码。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; top(nums.size()); // 牌堆数初始化为 0 int piles = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; // 要处理的扑克牌 int poker = nums[i]; // ***** 搜索左侧边界的二分查找 ***** int left = 0, right = piles; while (left &lt; right) &#123; int mid = (left + right) / 2; if (top[mid] &gt; poker) &#123; right = mid; &#125; else if (top[mid] &lt; poker) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; // ******************************** // 没找到合适的牌堆，新建一堆 if (left == piles) piles++; // 把这张牌放到牌堆顶 top[left] = poker; &#125; // 牌堆数就是 LIS 长度 return piles; &#125;&#125;; 931.下降路径最小和非常简单的思路，动态规划直接秒 123456789101112131415161718int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int size = matrix.size(); vector&lt;vector&lt;int&gt;&gt; dp(size, vector&lt;int&gt;(size, INT_MAX)); for (int j = 0; j &lt; size; j++) &#123; dp[0][j] = matrix[0][j]; &#125; for (int i = 1; i &lt; size; i++) &#123; for (int j = 0; j &lt; size; j++) &#123; for (int k = j - 1; k &lt;= j + 1; k++) &#123; if (k &gt;= 0 &amp;&amp; k &lt; size) &#123; dp[i][j] = min(dp[i - 1][k] + matrix[i][j], dp[i][j]); &#125; &#125; &#125; &#125; return *min_element(dp.back().begin(), dp.back().end());&#125; 贪心策略我的理解是，贪心是特殊的动态规划，贪心同样适合以从高到低的视角去分解成子问题，只不过这个子问题的解非常的显然，可以直接选出来。 55.跳跃游戏这道题怎么递归的去想呢，我们站在第0个元素，它能跳到哪些位置，是知道的，我们在这些地方继续递归，如果某个叶节点可以走到末尾，那就是能到的。如果每个叶节点都不能走到，那就是不能到的。 如果按照之前动态规划的思想，这道题应该是从最后的元素往上回溯，代码怎么写我是没想明白的。 这题的解法是从0位置元素向尾部迭代，所以这其实应该算是对递归进行一个剪枝？ 1234567891011bool canJump(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; dp(nums.size(), 0); dp[0] = nums[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; if (i &gt; dp[i - 1]) &#123; return false; &#125; dp[i] = max(dp[i - 1], i + nums[i]); &#125; return dp.back() &gt;= dp.size() - 1 ? true : false;&#125; dp[i]表示前第i个节点的能跳跃到的最大距离; 很显然，dp[i]只和dp[i-1]有关, 所以可以优化空间，只需要一个变量rightMax就行 1234567891011121314bool canJump(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int rightMax = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; if (i &gt; rightMax) &#123; return false; &#125; rightMax = max(rightMax, i + nums[i]); if (rightMax &gt;= len - 1) &#123; return true; &#125; &#125; return false;&#125; 45.跳跃游戏可有这样的递归方式 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;int&gt; memo; // 主函数 int jump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // 备忘录都初始化为 n，相当于 INT_MAX // 因为从 0 跳到 n - 1 最多 n - 1 步 memo = vector&lt;int&gt;(n, n); return dp(nums, 0); &#125; // 定义：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步 int dp(vector&lt;int&gt;&amp; nums, int p) &#123; int n = nums.size(); // base case if (p &gt;= n - 1) &#123; return 0; &#125; // 子问题已经计算过 if (memo[p] != n) &#123; return memo[p]; &#125; int steps = nums[p]; // 你可以选择跳 1 步，2 步... for (int i = 1; i &lt;= steps; i++) &#123; // 穷举每一个选择 // 计算每一个子问题的结果 int subProblem = dp(nums, p + i); // 取其中最小的作为最终结果 memo[p] = min(memo[p], subProblem + 1); &#125; return memo[p]; &#125;&#125;; 这道题的贪心性质可见下面的示意图 当你向后跳跃时，未来跳的最远的那个点，可以跳到其他方式可以到达打任意点，所以直接无脑选跳的最远的那个点就可以。故可以直接写成这样： 1234567891011121314151617181920int jump(vector&lt;int&gt;&amp; nums) &#123; int position = 0; int count = 0; while (position &lt; nums.size() - 1) &#123; int far = 0; int max_index = 0; for (int i = 1; i &lt;= nums[position]; i++) &#123; if (position + i &gt;= nums.size() - 1) &#123; return count + 1; &#125; if (position + i + nums[position + i] &gt; far) &#123; far = position + i + nums[position + i]; max_index = i; &#125; &#125; position = position + max_index; count++; &#125; return count;&#125; 这里要注意，返回的时机，position + i是当前能够跳到的地方，当你已经能够跳到最后一个元素的时候，即position + i &gt;= nums.size() - 1，直接着手返回即可。 当然，题解里的解法是一个for循环，这题解同样需要注意，和上一种for循环的范围是left &lt; nums.size() - 1。 这是因为，这个题解中，end是离你最近的一次farest，是一次起跳的起点。所以当left = 0时，跳跃基础就会增加一次，意味着从这里起跳。 123456789101112int jump(vector&lt;int&gt;&amp; nums) &#123; int farthest = 0, end = 0; int count = 0; for (int left = 0; left &lt; nums.size() - 1; left++) &#123; farthest = max(farthest, left + nums[left]); if (left == end) &#123; count++; end = farthest; &#125; &#125; return count;&#125; BFS遍历 如果你发现什么要求求出最短路径，不妨直接往BFS遍历去想一想 773.滑动谜题这道题实在是非常的巧妙，把每次移动，都看做是一个路径，每次移动后得到的结果，视为一个节点。用到了两个技巧： 2*3 的棋盘，按行遍历转换为字符串做唯一标识 棋盘每个位置的相邻元素，也就是可以移动的邻点，都是确定的，我们可以用固定的数组表示 有了这两个妙想后，就把这道题转换为了BFS遍历。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: std::string tran2str(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; string res = &quot;&quot;; for (auto&amp;&amp; line : board) &#123; for (auto&amp;&amp; c : line) &#123; res += to_string(c); &#125; &#125; return res; &#125; vector&lt;vector&lt;int&gt;&gt; neighbor_index = &#123;&#123;1, 3&#125;, &#123;0, 4, 2&#125;, &#123;1, 5&#125;, &#123;0, 4&#125;, &#123;3, 1, 5&#125;, &#123;4, 2&#125;&#125;; int slidingPuzzle(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; auto get_zero_index = [](string&amp; str) -&gt; int &#123; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] == &#x27;0&#x27;) &#123; return i; &#125; &#125; return 0; &#125;; auto swap_char = [](string str, int index1, int index2) &#123; swap(str[index1], str[index2]); return str; &#125;; int depth = 0; string initial = tran2str(board); queue&lt;string&gt; que; unordered_set&lt;string&gt; visited; que.push(initial); visited.insert(initial); while (que.size() &gt; 0) &#123; int size = que.size(); for (int i = 0; i &lt; size; i++) &#123; string front_str = que.front(); que.pop(); if (front_str == &quot;123450&quot;) &#123; return depth; &#125; int index = get_zero_index(front_str); vector&lt;int&gt; neighbors = neighbor_index[index]; for (int neighbor : neighbors) &#123; string new_str = swap_char(front_str, index, neighbor); if (visited.find(new_str) == visited.end()) &#123; que.push(new_str); visited.insert(new_str); &#125; &#125; &#125; depth++; &#125; return -1; &#125;&#125;; 注意： 需要使用一个visited集合记录已访问的节点，否则会陷入死循环 que和visited在初始化字符串的时候，就需要push和insert 只有当确认没有访问过这个节点，que和visited才需要push和insert 752.打开转盘锁这道题的思路和上一道题可以说是一模一样，但是需要注意的是，转’9’加一要到‘0’，‘0’减一要到’9’。 123456789101112131415161718192021222324252627282930313233343536373839404142int openLock(vector&lt;string&gt;&amp; deadends, string target) &#123; unordered_set&lt;string&gt; deadends_set(deadends.begin(), deadends.end()); if (deadends_set.find(&quot;0000&quot;) != deadends_set.end()) &#123; return -1; &#125; queue&lt;string&gt; que; unordered_set&lt;string&gt; visited; string initial = &quot;0000&quot;; que.push(initial); visited.insert(initial); int depth = 0; while (!que.empty()) &#123; int size = que.size(); for (int i = 0; i &lt; size; i++) &#123; string front_str = que.front(); que.pop(); if (front_str == target) &#123; return depth; &#125; for (int j = 0; j &lt; front_str.size(); j++) &#123; string new_str = front_str; new_str[j] = (new_str[j] == &#x27;9&#x27;) ? &#x27;0&#x27; : new_str[j] + 1; if (deadends_set.find(new_str) == deadends_set.end() &amp;&amp; visited.find(new_str) == visited.end()) &#123; visited.insert(new_str); que.push(new_str); &#125; string new_str2 = front_str; new_str2[j] = (new_str2[j] == &#x27;0&#x27;) ? &#x27;9&#x27; : new_str2[j] - 1; if (deadends_set.find(new_str2) == deadends_set.end() &amp;&amp; visited.find(new_str2) == visited.end()) &#123; visited.insert(new_str2); que.push(new_str2); &#125; &#125; &#125; depth++; &#125; return -1;&#125; 需要注意把vector的查找，转换为set的查找，否则时间复杂度直接就上去了，会有一些案例无法通过 一个很不错的优化方案，就是把deadends开始就加入到visited里，非常的合理和巧妙。"},{"title":"Hello World","path":"/2024/12/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]